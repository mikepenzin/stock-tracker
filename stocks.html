<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stock Tracker - Powered by Yahoo Finance</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
  <!-- Bootstrap Bundle JS (for modal) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
  <!-- EmailJS library -->
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3/dist/email.min.js"></script>
  <style>
    /* Alert card style for alerts modal */
    .alert-list-card {
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
      padding: 8px 14px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid #e0e0e0;
    }
    .alert-list-card .delete-alert {
      color: #ff4d4f;
      cursor: pointer;
      font-size: 1.2em;
      margin-left: 12px;
      transition: color 0.15s;
    }
    .alert-list-card .delete-alert:hover {
      color: #d32f2f;
    }
    /* Alert indicator bell icon styles */
    .alert-indicator {
      cursor: pointer;
      font-size: 1.1em;
      color: #6c757d;
      transition: color 0.2s ease;
      position: relative;
    }
    .alert-indicator:hover {
      color: #495057;
    }
    .alert-indicator.active {
      color: #dc3545;
    }
    .alert-indicator.active:hover {
      color: #c82333;
    }
    /* Alert count badge */
    .alert-count {
      position: absolute;
      top: -6px;
      right: -8px;
      background: #dc3545;
      color: #fff;
      border-radius: 10px;
      padding: 0 5px;
      font-size: 0.7em;
      min-width: 18px;
      text-align: center;
      pointer-events: none;
      z-index: 2;
      font-weight: bold;
      line-height: 1.4;
    }
    /* Make .form-text readable in dark mode */
    body.dark-mode .form-text {
      color: #bdbdbd !important;
    }
    /* Make .text-muted readable in dark mode */
    body.dark-mode .text-muted {
      color: #bdbdbd !important;
    }
    /* Strong dark mode override for all table cells and headers */
    body.dark-mode .table-darkmode th,
    body.dark-mode .table-darkmode td,
    body.dark-mode .table-dark th,
    body.dark-mode .table-dark td,
    body.dark-mode .stock-table-sm th,
    body.dark-mode .stock-table-sm td {
      color: #f8f9fa !important;
      background-color: #23272b !important;
      border-color: #444 !important;
    }
    body.dark-mode .table-striped > tbody > tr:nth-of-type(odd) > * {
      background-color: #23272b !important;
      color: #f8f9fa !important;
    }
    body.dark-mode .table-hover > tbody > tr:hover > * {
      background-color: #2a2d30 !important;
      color: #fff !important;
    }
    body.dark-mode .table thead th {
      color: #f8f9fa !important;
      background-color: #23272b !important;
      border-color: #444 !important;
    }
    
    /* Dropdown positioning fixes */
    .dropdown-menu {
      max-height: 300px;
      overflow-y: auto;
      white-space: nowrap;
    }
    
    /* Prevent dropdown from causing page scroll */
    .table-responsive {
      overflow: visible !important;
    }
    
    /* Ensure dropdowns stay within viewport */
    .dropdown-menu-end {
      right: 0 !important;
      left: auto !important;
    }
    
    /* Custom positioning for table dropdowns */
    .table .dropdown {
      position: static;
    }
    
    .table .dropdown-menu {
      position: absolute;
      z-index: 1000;
      min-width: 160px;
    }
    
    /* News categorization and highlighting styles */
    .cursor-pointer {
      cursor: pointer;
    }
    
    .highlight-flash {
      animation: highlightFlash 2s ease-out;
    }
    
    @keyframes highlightFlash {
      0% { 
        background-color: #fff3cd; 
        border-color: #ffc107;
        transform: scale(1.02);
      }
      50% { 
        background-color: #fff3cd; 
        border-color: #ffc107;
        transform: scale(1.02);
      }
      100% { 
        background-color: transparent; 
        border-color: initial;
        transform: scale(1);
      }
    }
    
    .news-item {
      transition: all 0.3s ease;
    }
    
    .news-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .badge.cursor-pointer:hover {
      transform: scale(1.05);
      filter: brightness(1.1);
    }
    body {
      font-family: Arial, sans-serif;
      background: #f4f6fa;
      margin: 0;
      padding: 0;
    }
    /* Remove max-width from container for full width */
    .container, .container-fluid {
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08);
      padding: 32px 24px 24px 24px;
      margin: 1.5vh;
      width: auto;

    }
    .up { color: #2ecc40; font-weight: bold; }
    .down { color: #ff4d4f; font-weight: bold; }
    .neutral { color: #888; }
    .warning { color: #ff8c00; font-weight: bold; }
    
    /* Smart Score Styling */
    .smart-score-container {
      min-width: 80px;
      font-size: 0.9em;
    }
    .smart-score-value {
      font-weight: bold;
      font-size: 1.1em;
      margin-bottom: 2px;
    }
    .smart-score-sentiment {
      font-size: 0.8em;
      text-transform: uppercase;
      font-weight: 600;
    }
    
    /* Smart Score Colors */
    .smart-score-bullish { 
      background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .smart-score-bearish { 
      background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .smart-score-neutral { 
      background: linear-gradient(135deg, #e2e3e5 0%, #d6d8db 100%);
      color: #383d41;
      border: 1px solid #d6d8db;
    }
    
    .smart-score-container {
      padding: 4px 8px;
      border-radius: 6px;
      text-align: center;
      margin: 2px auto;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .loading {
      text-align: center;
      color: #888;
      margin-top: 30px;
    }
    .stock-list {
      margin-top: 16px;
    }
    .card + .card { margin-top: 18px; }
    .stock-symbol { font-size: 1.2em; font-weight: bold; color: #333; transition: color 0.2s; }
    .info-row { font-size: 1em; }
    .label { color: #888; min-width: 90px; }
    .table th.sortable {
      cursor: pointer;
      user-select: none;
      position: relative;
      transition: background-color 0.2s ease;
    }
    .table th.sortable:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }
    .table-responsive {
      border-radius: 8px;
      border: 1px solid #dee2e6;
    }
    .table thead th {
      font-weight: 600;
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      padding: 12px 8px;
    }
    .table tbody td {
      padding: 10px 8px;
      vertical-align: middle;
    }
    /* Modal fixes to prevent cutoff */
    .modal-dialog {
      margin: 1rem auto;
      max-width: 90vw;
    }
    .modal-dialog.modal-lg {
      max-width: min(800px, 90vw);
    }
    .modal-content {
      max-height: 90vh;
      overflow-y: auto;
    }
    .modal-body {
      max-height: calc(90vh - 120px);
      overflow-y: auto;
    }
    @media (max-width: 700px) {
      .container, .container-fluid { padding: 12px 2vw; }
      .modal-dialog {
        margin: 0.5rem;
        max-width: calc(100vw - 1rem);
      }
      .modal-content {
        max-height: 95vh;
      }
      .modal-body {
        max-height: calc(95vh - 120px);
      }
    }
    
    /* Mobile tabs optimization */
    @media (max-width: 768px) {
      .nav-tabs {
        display: none;
      }
      .mobile-tabs-container {
        display: flex !important;
        align-items: center;
        gap: 0.5rem;
        margin-bottom: 1rem;
      }
      .mobile-tab-dropdown {
        flex: 1;
      }
      .mobile-tab-dropdown .dropdown-toggle {
        width: 100%;
        text-align: left;
        justify-content: space-between;
        display: flex;
        align-items: center;
      }
      .mobile-fixed-tabs {
        display: flex;
        gap: 0.25rem;
      }
      .mobile-fixed-tabs .nav-link {
        padding: 0.5rem 0.75rem;
        border: 1px solid #dee2e6;
        border-radius: 0.375rem;
        background: white;
        color: #495057;
        text-decoration: none;
        font-size: 0.875rem;
      }
      .mobile-fixed-tabs .nav-link.active {
        background: #007bff;
        color: white;
        border-color: #007bff;
      }
      .mobile-fixed-tabs .nav-link:hover {
        background: #f8f9fa;
        color: #007bff;
      }
      .mobile-fixed-tabs .nav-link.active:hover {
        background: #0056b3;
        color: white;
      }
    }
    
    @media (min-width: 769px) {
      .mobile-tabs-container {
        display: none !important;
      }
    }
    
    /* Mobile table optimization - horizontal scroll with fixed first column */
    @media (max-width: 768px) {
      .table-responsive {
        overflow-x: auto !important;
        -webkit-overflow-scrolling: touch;
      }
      
      .stock-table-mobile {
        position: relative;
        min-width: 800px; /* Force horizontal scroll */
      }
      
      .stock-table-mobile th:first-child,
      .stock-table-mobile td:first-child {
        position: sticky;
        left: 0;
        z-index: 10;
        background: white;
        box-shadow: 2px 0 4px rgba(0,0,0,0.1);
        min-width: 130px;
        max-width: 130px;
        border-right: 2px solid #dee2e6;
      }
      
      .stock-table-mobile thead th:first-child {
        z-index: 11;
        background: #f8f9fa;
        font-weight: 600;
      }
      
      /* Dark mode support for fixed column */
      body.dark-mode .stock-table-mobile th:first-child,
      body.dark-mode .stock-table-mobile td:first-child {
        background: #2b3035 !important;
        border-color: #444 !important;
        border-right-color: #555 !important;
      }
      
      body.dark-mode .stock-table-mobile thead th:first-child {
        background: #23272b !important;
      }
      
      /* Compact column sizes for mobile */
      .stock-table-mobile th,
      .stock-table-mobile td {
        min-width: 80px;
        padding: 0.25rem 0.5rem !important;
        font-size: 0.8rem !important;
        white-space: nowrap;
      }
      
      /* Price column needs more space */
      .stock-table-mobile th:nth-child(3),
      .stock-table-mobile td:nth-child(3) {
        min-width: 140px;
      }
      
      /* Actions column */
      .stock-table-mobile th:last-child,
      .stock-table-mobile td:last-child {
        min-width: 60px;
      }
      
      /* Icons column */
      .stock-table-mobile th:nth-child(2),
      .stock-table-mobile td:nth-child(2) {
        min-width: 50px;
        text-align: center;
      }
      
      /* Improve readability of company names in fixed column */
      .stock-table-mobile .stock-symbol {
        font-size: 0.9rem !important;
        font-weight: 600;
      }
      
      /* Make sure alert badges are visible in mobile */
      .stock-table-mobile .alert-indicator,
      .stock-table-mobile .notes-icon {
        font-size: 0.8rem;
      }
    }
    
    /* Expandable row styling */
    .expand-icon {
      transition: transform 0.2s ease;
      color: #6c757d;
    }
    
    .stock-details-row {
      border: none !important;
    }
    
    .stock-details-row td {
      border-top: none !important;
      background-color: #f8f9fa !important;
    }
    
    body.dark-mode .stock-details-row td {
      background-color: #343a40 !important;
    }
    
    .stock-details-row h6 {
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    
    .stock-details-row .mb-1 {
      margin-bottom: 0.25rem !important;
    }
    
    /* Index-specific styling */
    .index-card {
      border-left: 4px solid #007bff;
    }
    .index-card .card-title {
      color: #007bff;
      font-weight: 600;
    }
    .index-card .price {
      font-size: 1.2em;
      font-weight: bold;
    }
    .index-tab-icon {
      color: #007bff;
    }
    
    /* Stock card left border styling */
    .stock-card {
      border-left: 4px solid #6c757d; /* Default gray border */
    }
    .stock-card.border-success {
      border-left: 4px solid #28a745 !important; /* Green left border for up stocks */
      border-top: 1px solid #dee2e6;
      border-right: 1px solid #dee2e6;
      border-bottom: 1px solid #dee2e6;
    }
    .stock-card.border-danger {
      border-left: 4px solid #dc3545 !important; /* Red left border for down stocks */
      border-top: 1px solid #dee2e6;
      border-right: 1px solid #dee2e6;
      border-bottom: 1px solid #dee2e6;
    }
    .stock-card .price {
      font-size: 1.2em;
      font-weight: bold;
    }
    
    /* Index card left border styling for price direction */
    .index-card.border-success {
      border-left: 4px solid #28a745 !important; /* Green left border for up indexes */
      border-top: 1px solid #dee2e6;
      border-right: 1px solid #dee2e6;
      border-bottom: 1px solid #dee2e6;
    }
    .index-card.border-danger {
      border-left: 4px solid #dc3545 !important; /* Red left border for down indexes */
      border-top: 1px solid #dee2e6;
      border-right: 1px solid #dee2e6;
      border-bottom: 1px solid #dee2e6;
    }
    
    /* Market status indicator */
    .market-status {
      font-size: 0.8em;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 500;
    }
    .market-status.open {
      background-color: #d4edda;
      color: #155724;
    }
    .market-status.closed {
      background-color: #f8d7da;
      color: #721c24;
    }
    body.dark-mode .market-status.open {
      background-color: #155724;
      color: #d4edda;
    }
    body.dark-mode .market-status.closed {
      background-color: #721c24;
      color: #f8d7da;
    }
    
    /* Dark mode for navigation tabs */
    body.dark-mode .nav-tabs {
      border-bottom-color: #444 !important;
    }
    body.dark-mode .nav-tabs .nav-link {
      color: #adb5bd !important;
      background-color: transparent !important;
      border-color: transparent !important;
    }
    body.dark-mode .nav-tabs .nav-link:hover {
      color: #f8f9fa !important;
      background-color: #343a40 !important;
      border-color: #444 #444 #444 !important;
    }
    body.dark-mode .nav-tabs .nav-link.active {
      color: #f8f9fa !important;
      background-color: #212529 !important;
      border-color: #444 #444 transparent !important;
    }
    body.dark-mode .nav-tabs .nav-link.active:hover {
      color: #fff !important;
      background-color: #212529 !important;
      border-color: #444 #444 transparent !important;
    }
    
    /* Dark mode for dropdowns */
    body.dark-mode .dropdown-menu {
      background-color: #212529 !important;
      border-color: #444 !important;
      box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.4) !important;
    }
    body.dark-mode .dropdown-item {
      color: #adb5bd !important;
    }
    body.dark-mode .dropdown-item:hover,
    body.dark-mode .dropdown-item:focus {
      color: #f8f9fa !important;
      background-color: #343a40 !important;
    }
    body.dark-mode .dropdown-item.active {
      color: #fff !important;
      background-color: #0d6efd !important;
    }
    body.dark-mode .dropdown-item:active {
      color: #fff !important;
      background-color: #0d6efd !important;
    }
    body.dark-mode .dropdown-header {
      color: #6c757d !important;
    }
    body.dark-mode .dropdown-divider {
      border-top-color: #444 !important;
    }
    body.dark-mode .dropdown-item.text-danger {
      color: #dc3545 !important;
    }
    body.dark-mode .dropdown-item.text-danger:hover,
    body.dark-mode .dropdown-item.text-danger:focus {
      color: #fff !important;
      background-color: #dc3545 !important;
    }
    
    /* News section styling */
    .news-item {
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .news-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .news-item.border-info {
      border-left: 4px solid #0dcaf0 !important;
    }
    .news-link {
      color: inherit !important;
      font-weight: 500;
      line-height: 1.3;
    }
    .news-link:hover {
      color: #0d6efd !important;
    }
    
    /* Dark mode for news */
    body.dark-mode .news-item {
      background-color: #2b3035 !important;
      border-color: #444 !important;
    }
    body.dark-mode .news-item:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    body.dark-mode .news-item.border-info {
      border-left-color: #0dcaf0 !important;
    }
    body.dark-mode .news-link {
      color: #f8f9fa !important;
    }
    body.dark-mode .news-link:hover {
      color: #66b3ff !important;
    }
    
    /* Spinner animation */
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .spin {
      animation: spin 1s linear infinite;
    }
    
    /* Tab spacing adjustment */
    .nav-tabs .nav-item.ms-auto {
      margin-left: auto !important;
    }
    
    /* Indexes tab special styling */
    #indexes-tab {
      color: #6c757d !important;
      border-color: transparent !important;
      background-color: rgba(108, 117, 125, 0.1) !important;
      font-weight: 500 !important;
    }
    
    #indexes-tab:hover {
      color: #495057 !important;
      background-color: rgba(108, 117, 125, 0.2) !important;
      border-color: rgba(108, 117, 125, 0.3) !important;
    }
    
    #indexes-tab.active {
      color: #495057 !important;
      background-color: rgba(108, 117, 125, 0.2) !important;
      border-color: rgba(108, 117, 125, 0.3) !important;
      font-weight: 600 !important;
    }
    
    #indexes-tab.active:hover {
      color: #495057 !important;
      background-color: rgba(108, 117, 125, 0.2) !important;
      border-color: rgba(108, 117, 125, 0.3) !important;
    }
    
    /* Dark mode adjustments for indexes tab */
    body.dark-mode #indexes-tab {
      color: #adb5bd !important;
      background-color: rgba(173, 181, 189, 0.15) !important;
    }
    
    body.dark-mode #indexes-tab:hover {
      color: #dee2e6 !important;
      background-color: rgba(173, 181, 189, 0.25) !important;
      border-color: rgba(173, 181, 189, 0.4) !important;
    }
    
    body.dark-mode #indexes-tab.active {
      color: #dee2e6 !important;
      background-color: rgba(173, 181, 189, 0.25) !important;
      border-color: rgba(173, 181, 189, 0.4) !important;
    }
    
    body.dark-mode #indexes-tab.active:hover {
      color: #dee2e6 !important;
      background-color: rgba(173, 181, 189, 0.25) !important;
      border-color: rgba(173, 181, 189, 0.4) !important;
    }
    
    /* Notes icon styles */
    .notes-icon {
      cursor: pointer;
      font-size: 1.1em;
      color: #6c757d;
      transition: color 0.2s ease;
      margin-left: 4px;
    }
    .notes-icon:hover {
      color: #495057;
    }
    .notes-icon.has-notes {
      color: #6c757d;
    }
    .notes-icon.has-notes:hover {
      color: #606164;
    }
    
    /* Dark mode for notes icon */
    body.dark-mode .notes-icon {
      color: #adb5bd;
    }
    body.dark-mode .notes-icon:hover {
      color: #dee2e6;
    }
    body.dark-mode .notes-icon.has-notes {
      color: #adb5bd;
    }
    body.dark-mode .notes-icon.has-notes:hover {
      color: #878c92;
    }
    
    /* Notes modal styling */
    .notes-textarea {
      min-height: 120px;
      resize: vertical;
    }
    .note-preview {
      font-size: 0.875em;
      color: #6c757d;
      font-style: italic;
      max-width: 200px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    body.dark-mode .note-preview {
      color: #adb5bd;
    }
    
    /* Notes tagging system */
    .note-tag {
      display: inline-block;
      background: #e3f2fd;
      color: #1976d2;
      padding: 2px 6px;
      border-radius: 10px;
      font-size: 0.75em;
      font-weight: 500;
      margin: 1px 2px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid #bbdefb;
    }
    .note-tag:hover {
      background: #bbdefb;
      transform: scale(1.05);
    }
    .note-tag.selected {
      background: #1976d2;
      color: white;
    }
    
    /* Dark mode for tags */
    body.dark-mode .note-tag {
      background: #1e3a8a;
      color: #93c5fd;
      border-color: #1e40af;
    }
    body.dark-mode .note-tag:hover {
      background: #1e40af;
      color: #dbeafe;
    }
    body.dark-mode .note-tag.selected {
      background: #3b82f6;
      color: white;
    }
    
    /* Tag input and suggestions */
    .tag-input-container {
      position: relative;
    }
    .tag-suggestions {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      max-height: 150px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    .tag-suggestion {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid #f8f9fa;
    }
    .tag-suggestion:hover,
    .tag-suggestion.active {
      background: #f8f9fa;
    }
    .tag-suggestion:last-child {
      border-bottom: none;
    }
    
    /* Dark mode for tag suggestions */
    body.dark-mode .tag-suggestions {
      background: #2b3035;
      border-color: #444;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    body.dark-mode .tag-suggestion {
      color: #f8f9fa;
      border-bottom-color: #444;
    }
    body.dark-mode .tag-suggestion:hover,
    body.dark-mode .tag-suggestion.active {
      background: #343a40;
    }
    
    /* Notes filter and search */
    .notes-filter-container {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
      padding: 8px;
      background: #f8f9fa;
      border-radius: 6px;
      border: 1px solid #e9ecef;
    }
    .notes-filter-container.has-filters {
      border-color: #0d6efd;
      background: #f0f8ff;
    }
    body.dark-mode .notes-filter-container {
      background: #2b3035;
      border-color: #444;
    }
    body.dark-mode .notes-filter-container.has-filters {
      background: #1a2332;
      border-color: #3b82f6;
    }
    
    /* Tag count indicator */
    .tag-count {
      font-size: 0.7em;
      background: #6c757d;
      color: white;
      border-radius: 8px;
      padding: 1px 4px;
      margin-left: 3px;
    }
    
    /* Stock input autocomplete */
    .stock-input-container {
      position: relative;
    }
    .stock-autocomplete {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 1px solid #dee2e6;
      border-top: none;
      border-radius: 0 0 4px 4px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }
    .stock-suggestion {
      padding: 12px 15px;
      cursor: pointer;
      border-bottom: 1px solid #f8f9fa;
      transition: background-color 0.15s ease;
    }
    .stock-suggestion:hover,
    .stock-suggestion.active {
      background: #f8f9fa;
    }
    .stock-suggestion:last-child {
      border-bottom: none;
    }
    .stock-suggestion-symbol {
      font-weight: 600;
      color: #0d6efd;
      font-size: 1em;
    }
    .stock-suggestion-name {
      color: #6c757d;
      font-size: 0.9em;
      margin-top: 2px;
      line-height: 1.3;
    }
    .stock-suggestion-exchange {
      font-size: 0.8em;
      color: #adb5bd;
      margin-top: 1px;
    }
    .stock-suggestion-type {
      display: inline-block;
      background: #e9ecef;
      color: #495057;
      padding: 1px 6px;
      border-radius: 10px;
      font-size: 0.7em;
      margin-left: 8px;
    }
    
    /* Dark mode for stock autocomplete */
    body.dark-mode .stock-autocomplete {
      background: #2b3035;
      border-color: #444;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    body.dark-mode .stock-suggestion {
      border-bottom-color: #444;
      color: #f8f9fa;
    }
    body.dark-mode .stock-suggestion:hover,
    body.dark-mode .stock-suggestion.active {
      background: #343a40;
    }
    body.dark-mode .stock-suggestion-symbol {
      color: #66b3ff;
    }
    body.dark-mode .stock-suggestion-name {
      color: #adb5bd;
    }
    body.dark-mode .stock-suggestion-exchange {
      color: #6c757d;
    }
    body.dark-mode .stock-suggestion-type {
      background: #495057;
      color: #adb5bd;
    }
    
    /* Loading indicator for autocomplete */
    .autocomplete-loading {
      padding: 12px 15px;
      text-align: center;
      color: #6c757d;
      font-size: 0.9em;
    }
    body.dark-mode .autocomplete-loading {
      color: #adb5bd;
    }
    
    /* Table view enhancements */
    .stock-table-sm .alert-indicator,
    .stock-table-sm .notes-icon {
      font-size: 0.9em;
      margin: 0 2px;
    }
    
    /* Trend indicators styling */
    .trend-indicator {
      font-size: 0.8em;
      font-weight: bold;
      margin-left: 4px;
    }
    
    /* Company name styling in table */
    .company-name-small {
      font-size: 0.7rem;
      color: #6c757d;
      line-height: 1.1;
      margin-top: 1px;
    }
    
    body.dark-mode .company-name-small {
      color: #adb5bd;
    }
    
    /* Minimal spacing for tiny.site banner - reduced to prevent double banner appearance */
    body {
      padding-bottom: 40px !important;
    }
    
    .container-fluid {
      margin-bottom: 20px;
    }
    
    /* Hide potential duplicate tiny.site banners or ads */
    [class*="banner"]:not(:first-child),
    [id*="banner"]:not(:first-child),
    [class*="ad"]:not(:first-child),
    iframe[src*="ads"]:not(:first-child) {
      display: none !important;
    }
    
    /* Ensure only one banner shows at the bottom */
    body > div[style*="position: fixed"]:not(:first-of-type) {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <h1><i class="bi bi-file-earmark-bar-graph-fill me-2"></i>Stock Tracker <small class="text-muted" style="font-size:0.4em;">Powered by Yahoo Finance</small></h1>
    <form class="add-stock" id="addStockForm">
      <div class="d-flex mb-3" style="gap: 8px;">
        <div class="flex-grow-1">
          <div class="stock-input-container">
            <div class="input-group">
              <input type="text" id="stockInput" class="form-control" placeholder="Add stock symbol (e.g. AAPL, MSFT)" required maxlength="10" autocomplete="off" />
              <button type="submit" class="btn btn-primary">Add</button>
            </div>
            <div class="stock-autocomplete" id="stockAutocomplete">
              <!-- Autocomplete suggestions will appear here -->
            </div>
          </div>
        </div>
        <button id="settingsBtn" type="button" class="btn btn-outline-dark" title="Settings"><i class="bi bi-gear"></i></button>
      </div>
    </form>
    <div class="mb-2">
      <input type="text" id="filterInput" class="form-control" placeholder="Filter stocks..." style="max-width:300px; display:inline-block;" />
      <span id="fetchError" class="text-danger ms-3" style="display:none;"></span>
      <small id="cacheStatus" class="text-muted ms-3" style="display:none;"></small>
    </div>

    <!-- Watchlist Tabs -->
    <div class="mb-3">
      <!-- Desktop tabs (hidden on mobile) -->
      <ul class="nav nav-tabs" id="watchlistTabs" role="tablist">
        <!-- Tabs will be dynamically generated -->
      </ul>
      
      <!-- Mobile tabs (hidden on desktop) -->
      <div class="mobile-tabs-container" style="display: none;">
        <div class="mobile-tab-dropdown">
          <div class="dropdown">
            <button class="btn btn-outline-secondary dropdown-toggle" type="button" id="mobileTabDropdown" data-bs-toggle="dropdown" aria-expanded="false">
              <span id="mobileActiveTabText">Main</span>
            </button>
            <ul class="dropdown-menu" id="mobileTabDropdownMenu" aria-labelledby="mobileTabDropdown">
              <!-- Dropdown items will be dynamically generated -->
            </ul>
          </div>
        </div>
        <div class="mobile-fixed-tabs">
          <button class="nav-link" type="button" onclick="showAddWatchlistModal()" title="Manage watchlists">
            <i class="bi bi-gear-fill"></i>
          </button>
          <button class="nav-link" type="button" onclick="switchToNews()" title="News" id="mobile-news-tab">
            <i class="bi bi-newspaper me-1"></i>News
          </button>
        </div>
      </div>
    </div>
    <!-- Settings Modal -->
    <div class="modal fade" id="settingsModal" tabindex="-1" aria-labelledby="settingsModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="settingsModalLabel">Settings</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <!-- Display Options -->
            <div class="row mb-3">
              <div class="col-6">
                <div class="form-check form-switch">
                  <input class="form-check-input" type="checkbox" id="tableViewSwitch">
                  <label class="form-check-label" for="tableViewSwitch">Table view</label>
                </div>
              </div>
              <div class="col-6">
                <div class="form-check form-switch">
                  <input class="form-check-input" type="checkbox" id="darkModeSwitch">
                  <label class="form-check-label" for="darkModeSwitch">Dark mode</label>
                </div>
              </div>
            </div>
            
            <!-- Smart Score Settings -->
            <div class="mb-3">
              <label class="form-label">Smart Score & Alerts</label>
              <div class="row">
                <div class="col-12">
                  <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="smartAlertsSwitch">
                    <label class="form-check-label" for="smartAlertsSwitch">
                      Enable Smart Alerts
                      <small class="text-muted d-block">Get notifications when Smart Score crosses thresholds</small>
                    </label>
                  </div>
                </div>
              </div>
              <div id="smartAlertSettings" class="ms-3" style="display: none;">
                <div class="row g-2">
                  <div class="col-6">
                    <label for="smartAlertBuyThreshold" class="form-label small">Buy Alert (≥)</label>
                    <input type="number" id="smartAlertBuyThreshold" class="form-control form-control-sm" min="50" max="100" placeholder="75" />
                  </div>
                  <div class="col-6">
                    <label for="smartAlertSellThreshold" class="form-label small">Sell Alert (≤)</label>
                    <input type="number" id="smartAlertSellThreshold" class="form-control form-control-sm" min="0" max="50" placeholder="25" />
                  </div>
                </div>
                <div class="form-check mt-2">
                  <input class="form-check-input" type="checkbox" id="smartAlertEmailSwitch">
                  <label class="form-check-label small" for="smartAlertEmailSwitch">
                    Send email alerts (requires email above)
                  </label>
                </div>
              </div>
            </div>
            
            <!-- Refresh Settings -->
            <div class="mb-3">
              <label for="refreshInterval" class="form-label">Auto-refresh (minutes):</label>
              <input type="number" id="refreshInterval" class="form-control" min="1" max="60" placeholder="15" />
            </div>
            
            <!-- Alert Email -->
            <div class="mb-3">
              <label for="userEmail" class="form-label">Alert Email:</label>
              <input type="email" id="userEmail" class="form-control" placeholder="your@email.com (optional)" />
            </div>
            
            <!-- Quick Actions -->
            <div class="mb-3">
              <label class="form-label">Quick Actions:</label>
              <div class="d-grid gap-2">
                <button type="button" class="btn btn-outline-warning btn-sm" id="forceHistoricalBtn">
                  <i class="bi bi-arrow-clockwise me-1"></i> Refresh All Data
                </button>
                <div class="row g-2">
                  <div class="col-6">
                    <button id="exportBtn" class="btn btn-outline-primary btn-sm w-100">
                      <i class="bi bi-download me-1"></i> Export
                    </button>
                  </div>
                  <div class="col-6">
                    <button id="importBtn" class="btn btn-outline-success btn-sm w-100">
                      <i class="bi bi-upload me-1"></i> Import
                    </button>
                  </div>
                </div>
              </div>
              <input type="file" id="importFile" accept="application/json" style="display:none;" />
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            <button type="button" class="btn btn-primary" id="saveSettingsBtn">Save</button>
          </div>
        </div>
      </div>
    </div>
  <script>
    // --- Alerts Data Model ---
    function getAlerts(symbol) {
      const all = JSON.parse(localStorage.getItem('stockAlerts') || '{}');
      return all[symbol] || [];
    }
    function setAlerts(symbol, alerts) {
      const all = JSON.parse(localStorage.getItem('stockAlerts') || '{}');
      all[symbol] = alerts;
      localStorage.setItem('stockAlerts', JSON.stringify(all));
    }
    function getAllAlerts() {
      return JSON.parse(localStorage.getItem('stockAlerts') || '{}');
    }
    
    // --- Notes Data Model ---
    function getNotesKey() {
      const currentWatchlist = getCurrentWatchlistName();
      return `stockNotes_${currentWatchlist}`;
    }
    
    function getNotes(symbol) {
      const notesKey = getNotesKey();
      const allNotes = JSON.parse(localStorage.getItem(notesKey) || '{}');
      return allNotes[symbol] || '';
    }
    
    function setNotes(symbol, notes) {
      const notesKey = getNotesKey();
      const allNotes = JSON.parse(localStorage.getItem(notesKey) || '{}');
      if (notes && notes.trim()) {
        allNotes[symbol] = notes.trim();
      } else {
        delete allNotes[symbol];
      }
      localStorage.setItem(notesKey, JSON.stringify(allNotes));
    }
    
    function getAllNotes() {
      const notesKey = getNotesKey();
      return JSON.parse(localStorage.getItem(notesKey) || '{}');
    }
    
    function hasNotes(symbol) {
      const notes = getNotes(symbol);
      return notes && notes.trim().length > 0;
    }
    
    function getAllNotesForExport() {
      const watchlists = getWatchlists();
      const allNotesData = {};
      
      watchlists.forEach(watchlist => {
        const notesKey = `stockNotes_${watchlist.name}`;
        const watchlistNotes = JSON.parse(localStorage.getItem(notesKey) || '{}');
        if (Object.keys(watchlistNotes).length > 0) {
          allNotesData[watchlist.name] = watchlistNotes;
        }
      });
      
      return allNotesData;
    }
    
    // --- Advanced Notes Tagging System ---
    function extractTagsFromText(text) {
      if (!text) return [];
      const tagRegex = /#([a-zA-Z0-9_]+)/g;
      const tags = [];
      let match;
      while ((match = tagRegex.exec(text)) !== null) {
        const tag = match[1].toLowerCase();
        if (!tags.includes(tag)) {
          tags.push(tag);
        }
      }
      return tags;
    }
    
    function getAllTagsFromAllNotes() {
      const allNotes = getAllNotes();
      const tagCounts = {};
      
      Object.values(allNotes).forEach(noteText => {
        const tags = extractTagsFromText(noteText);
        tags.forEach(tag => {
          tagCounts[tag] = (tagCounts[tag] || 0) + 1;
        });
      });
      
      // Return tags sorted by frequency
      return Object.entries(tagCounts)
        .sort(([,a], [,b]) => b - a)
        .map(([tag, count]) => ({ tag, count }));
    }
    
    function getStocksByTag(tag) {
      const allNotes = getAllNotes();
      const stocksWithTag = [];
      
      Object.entries(allNotes).forEach(([symbol, noteText]) => {
        const tags = extractTagsFromText(noteText);
        if (tags.includes(tag.toLowerCase())) {
          stocksWithTag.push(symbol);
        }
      });
      
      return stocksWithTag;
    }
    
    function getSuggestedTags() {
      // Common trading and investment tags
      const commonTags = [
        'bullish', 'bearish', 'breakout', 'support', 'resistance', 'earnings',
        'dividend', 'swing', 'longterm', 'shortterm', 'volatile', 'stable',
        'oversold', 'overbought', 'momentum', 'reversal', 'trend', 'sideways',
        'buy', 'sell', 'hold', 'watch', 'alert', 'research', 'news',
        'catalyst', 'risk', 'opportunity', 'analysis', 'target', 'stop'
      ];
      
      // Get user's existing tags
      const userTags = getAllTagsFromAllNotes().map(item => item.tag);
      
      // Combine and deduplicate
      const allSuggested = [...new Set([...userTags, ...commonTags])];
      
      return allSuggested.map(tag => ({
        tag,
        count: userTags.includes(tag) ? getAllTagsFromAllNotes().find(item => item.tag === tag)?.count || 0 : 0,
        isCommon: commonTags.includes(tag)
      })).sort((a, b) => {
        // Sort by: user tags first (by count), then common tags alphabetically
        if (a.count > 0 && b.count === 0) return -1;
        if (a.count === 0 && b.count > 0) return 1;
        if (a.count > 0 && b.count > 0) return b.count - a.count;
        return a.tag.localeCompare(b.tag);
      });
    }
    
    function categorizeNotesByTags(notes) {
      const categories = {
        sentiment: { bullish: [], bearish: [], neutral: [] },
        timeframe: { longterm: [], shortterm: [], swing: [] },
        action: { buy: [], sell: [], hold: [], watch: [] },
        analysis: { technical: [], fundamental: [], news: [] },
        uncategorized: []
      };
      
      Object.entries(notes).forEach(([symbol, noteText]) => {
        const tags = extractTagsFromText(noteText);
        let categorized = false;
        
        // Sentiment categorization
        if (tags.some(tag => ['bullish', 'buy', 'opportunity'].includes(tag))) {
          categories.sentiment.bullish.push(symbol);
          categorized = true;
        } else if (tags.some(tag => ['bearish', 'sell', 'risk'].includes(tag))) {
          categories.sentiment.bearish.push(symbol);
          categorized = true;
        }
        
        // Timeframe categorization
        if (tags.some(tag => ['longterm', 'dividend', 'hold'].includes(tag))) {
          categories.timeframe.longterm.push(symbol);
          categorized = true;
        } else if (tags.some(tag => ['shortterm', 'swing', 'momentum'].includes(tag))) {
          categories.timeframe.shortterm.push(symbol);
          categorized = true;
        }
        
        // Action categorization
        if (tags.includes('buy') && !categories.action.buy.includes(symbol)) {
          categories.action.buy.push(symbol);
          categorized = true;
        } else if (tags.includes('sell') && !categories.action.sell.includes(symbol)) {
          categories.action.sell.push(symbol);
          categorized = true;
        } else if (tags.includes('hold') && !categories.action.hold.includes(symbol)) {
          categories.action.hold.push(symbol);
          categorized = true;
        } else if (tags.includes('watch') && !categories.action.watch.includes(symbol)) {
          categories.action.watch.push(symbol);
          categorized = true;
        }
        
        if (!categorized) {
          categories.uncategorized.push(symbol);
        }
      });
      
      return categories;
    }
    function removeAlert(symbol, alertId) {
      let alerts = getAlerts(symbol);
      alerts = alerts.filter(a => a.id !== alertId);
      setAlerts(symbol, alerts);
      
      // Update alert badges immediately
      const alertCount = alerts.length;
      const alertBellEl = document.getElementById(`${symbol}-alertBell`);
      const alertBellTableEl = document.getElementById(`${symbol}-alertBell-table`);
      
      if (alertBellEl) {
        updateAlertBadge(alertBellEl, alertCount);
        if (alertCount > 0) {
          alertBellEl.classList.add('active');
          alertBellEl.title = `View ${alertCount} alert${alertCount > 1 ? 's' : ''}`;
        } else {
          alertBellEl.classList.remove('active');
          alertBellEl.title = 'Add alert';
        }
      }
      
      if (alertBellTableEl) {
        updateAlertBadge(alertBellTableEl, alertCount);
        if (alertCount > 0) {
          alertBellTableEl.classList.add('active');
          alertBellTableEl.title = `View ${alertCount} alert${alertCount > 1 ? 's' : ''}`;
        } else {
          alertBellTableEl.classList.remove('active');
          alertBellTableEl.title = 'Add alert';
        }
      }
    }
    function addAlert(symbol, field, op, value) {
      let alerts = getAlerts(symbol);
      alerts.push({ id: Date.now() + Math.random().toString(36).slice(2), field, op, value: Number(value) });
      setAlerts(symbol, alerts);
      
      // Update alert badges immediately
      const alertCount = alerts.length;
      const alertBellEl = document.getElementById(`${symbol}-alertBell`);
      const alertBellTableEl = document.getElementById(`${symbol}-alertBell-table`);
      
      if (alertBellEl) {
        updateAlertBadge(alertBellEl, alertCount);
        alertBellEl.classList.add('active');
        alertBellEl.title = `View ${alertCount} alert${alertCount > 1 ? 's' : ''}`;
      }
      
      if (alertBellTableEl) {
        updateAlertBadge(alertBellTableEl, alertCount);
        alertBellTableEl.classList.add('active');
        alertBellTableEl.title = `View ${alertCount} alert${alertCount > 1 ? 's' : ''}`;
      }
    }

    // --- Alerts Modal Logic ---
    let currentAlertsSymbol = null;
    function showAlertsModal(symbol) {
      currentAlertsSymbol = symbol;
      document.getElementById('alertsModalSymbol').textContent = symbol;
      renderAlertsList(symbol);
      const modal = new bootstrap.Modal(document.getElementById('alertsModal'));
      modal.show();
    }
    function renderAlertsList(symbol) {
      const list = document.getElementById('alertsList');
      const alerts = getAlerts(symbol);
      list.innerHTML = alerts.length ? '' : '<div class="text-muted">No alerts set.</div>';
      alerts.forEach(alert => {
        const card = document.createElement('div');
        card.className = 'alert-list-card';
        
        // Format the value display based on field type
        let displayValue = alert.value;
        let fieldDisplay = alert.field;
        
        if (alert.field === 'price' || alert.field === 'ma50' || alert.field === 'ma200' || alert.field === 'atr14') {
          displayValue = '$' + alert.value.toFixed(2);
        } else if (alert.field === 'volume') {
          displayValue = (alert.value / 1e6).toFixed(1) + 'M';
        } else if (alert.field === 'rsi') {
          displayValue = alert.value.toFixed(1);
        }
        
        // Improve field names
        if (alert.field === 'ma50') fieldDisplay = '50-day Avg';
        if (alert.field === 'ma200') fieldDisplay = '200-day Avg';
        if (alert.field === 'atr14') fieldDisplay = 'ATR(14)';
        if (alert.field === 'rsi') fieldDisplay = 'RSI(14)';
        if (alert.field === 'price') fieldDisplay = 'Price';
        if (alert.field === 'volume') fieldDisplay = 'Volume';
        
        card.innerHTML = `<span><b>${fieldDisplay}</b> ${alert.op} <b>${displayValue}</b></span> <i class="bi bi-trash delete-alert" title="Delete"></i>`;
        card.querySelector('.delete-alert').onclick = () => {
          removeAlert(symbol, alert.id);
          renderAlertsList(symbol);
        };
        list.appendChild(card);
      });
    }
    
    // --- Notes Modal Logic ---
    let currentNotesSymbol = null;
    let selectedTagFilters = [];
    
    function showNotesModal(symbol) {
      currentNotesSymbol = symbol;
      document.getElementById('notesModalSymbol').textContent = symbol;
      
      const noteContent = document.getElementById('noteContent');
      const clearNotesBtn = document.getElementById('clearNotesBtn');
      
      // Load existing notes
      const existingNotes = getNotes(symbol);
      noteContent.value = existingNotes;
      
      // Show/hide clear button based on existing notes
      if (existingNotes && existingNotes.trim()) {
        clearNotesBtn.style.display = 'inline-block';
      } else {
        clearNotesBtn.style.display = 'none';
      }
      
      // Setup tagging interface
      setupTaggingInterface();
      updateCurrentTags();
      updateQuickTagButtons();
      updateAllTagsOverview();
      
      // Focus the textarea
      setTimeout(() => noteContent.focus(), 100);
      
      const modal = new bootstrap.Modal(document.getElementById('notesModal'));
      modal.show();
    }
    
    function setupTaggingInterface() {
      const noteContent = document.getElementById('noteContent');
      const tagSuggestions = document.getElementById('tagSuggestions');
      
      // Real-time tag detection and suggestions
      noteContent.addEventListener('input', function() {
        updateCurrentTags();
        
        const text = noteContent.value;
        const cursorPos = noteContent.selectionStart;
        
        // Check if user is typing a hashtag
        const beforeCursor = text.slice(0, cursorPos);
        const hashtagMatch = beforeCursor.match(/#([a-zA-Z0-9_]*)$/);
        
        if (hashtagMatch) {
          const partialTag = hashtagMatch[1].toLowerCase();
          showTagSuggestions(partialTag, cursorPos - hashtagMatch[0].length);
        } else {
          hideTagSuggestions();
        }
        
        // Update clear button visibility
        const clearNotesBtn = document.getElementById('clearNotesBtn');
        if (text.trim()) {
          clearNotesBtn.style.display = 'inline-block';
        } else {
          clearNotesBtn.style.display = 'none';
        }
      });
      
      // Hide suggestions when clicking outside
      noteContent.addEventListener('blur', function() {
        setTimeout(() => hideTagSuggestions(), 200);
      });
    }
    
    function showTagSuggestions(partialTag, insertPos) {
      const tagSuggestions = document.getElementById('tagSuggestions');
      const suggestedTags = getSuggestedTags();
      
      const filteredSuggestions = suggestedTags.filter(item => 
        item.tag.toLowerCase().includes(partialTag) && 
        item.tag.toLowerCase() !== partialTag
      );
      
      if (filteredSuggestions.length === 0) {
        hideTagSuggestions();
        return;
      }
      
      let suggestionsHtml = '';
      filteredSuggestions.slice(0, 8).forEach((item, index) => {
        const displayText = item.count > 0 ? `#${item.tag} (${item.count})` : `#${item.tag}`;
        suggestionsHtml += `
          <div class="tag-suggestion ${index === 0 ? 'active' : ''}" 
               data-tag="${item.tag}" 
               onclick="insertTag('${item.tag}', ${insertPos})">
            ${displayText}
            ${item.isCommon ? '<small class="text-muted ms-1">common</small>' : ''}
          </div>`;
      });
      
      tagSuggestions.innerHTML = suggestionsHtml;
      tagSuggestions.style.display = 'block';
    }
    
    function hideTagSuggestions() {
      const tagSuggestions = document.getElementById('tagSuggestions');
      tagSuggestions.style.display = 'none';
    }
    
    function insertTag(tag, insertPos) {
      const noteContent = document.getElementById('noteContent');
      const text = noteContent.value;
      
      // Find the start of the current hashtag being typed
      const beforeInsert = text.slice(0, insertPos);
      const hashIndex = beforeInsert.lastIndexOf('#');
      
      // Replace the partial hashtag with the complete tag
      const newText = text.slice(0, hashIndex) + '#' + tag + ' ' + text.slice(noteContent.selectionStart);
      noteContent.value = newText;
      
      // Position cursor after the inserted tag
      const newCursorPos = hashIndex + tag.length + 2;
      noteContent.setSelectionRange(newCursorPos, newCursorPos);
      noteContent.focus();
      
      hideTagSuggestions();
      updateCurrentTags();
    }
    
    function updateCurrentTags() {
      const noteContent = document.getElementById('noteContent');
      const currentTagsContainer = document.getElementById('currentTagsContainer');
      const currentTags = document.getElementById('currentTags');
      
      const tags = extractTagsFromText(noteContent.value);
      
      if (tags.length > 0) {
        currentTagsContainer.style.display = 'block';
        currentTags.innerHTML = tags.map(tag => 
          `<span class="note-tag" onclick="removeTagFromNote('${tag}')">#${tag} <i class="bi bi-x"></i></span>`
        ).join('');
      } else {
        currentTagsContainer.style.display = 'none';
      }
    }
    
    function removeTagFromNote(tagToRemove) {
      const noteContent = document.getElementById('noteContent');
      let text = noteContent.value;
      
      // Remove all instances of this tag (with various spacing patterns)
      const tagPatterns = [
        new RegExp(`#${tagToRemove}\\s+`, 'gi'),  // #tag followed by space(s)
        new RegExp(`#${tagToRemove}$`, 'gi'),     // #tag at end of text
        new RegExp(`\\s#${tagToRemove}\\s`, 'gi'), // #tag surrounded by spaces
        new RegExp(`\\s#${tagToRemove}$`, 'gi')   // #tag at end with space before
      ];
      
      tagPatterns.forEach(pattern => {
        text = text.replace(pattern, (match) => {
          if (match.includes(' ')) {
            return match.startsWith(' ') && match.endsWith(' ') ? ' ' : 
                   match.startsWith(' ') ? '' : 
                   match.endsWith(' ') ? ' ' : '';
          }
          return '';
        });
      });
      
      noteContent.value = text.trim();
      updateCurrentTags();
    }
    
    function updateQuickTagButtons() {
      const quickTagButtons = document.getElementById('quickTagButtons');
      const suggestedTags = getSuggestedTags();
      const currentTags = extractTagsFromText(document.getElementById('noteContent').value);
      
      // Show most common/recent tags as quick buttons
      const quickTags = suggestedTags.slice(0, 12);
      
      quickTagButtons.innerHTML = quickTags.map(item => {
        const isActive = currentTags.includes(item.tag);
        const buttonClass = isActive ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-secondary';
        const countText = item.count > 0 ? ` (${item.count})` : '';
        
        return `
          <button type="button" class="${buttonClass}" 
                  onclick="toggleQuickTag('${item.tag}')" 
                  ${isActive ? 'disabled' : ''}>
            #${item.tag}${countText}
          </button>`;
      }).join('');
    }
    
    function toggleQuickTag(tag) {
      const noteContent = document.getElementById('noteContent');
      const currentTags = extractTagsFromText(noteContent.value);
      
      if (!currentTags.includes(tag)) {
        // Add tag
        const currentText = noteContent.value.trim();
        const newText = currentText ? `${currentText} #${tag}` : `#${tag}`;
        noteContent.value = newText;
        updateCurrentTags();
        updateQuickTagButtons();
      }
    }
    
    function updateAllTagsOverview() {
      const allTagsOverview = document.getElementById('allTagsOverview');
      const allTags = getAllTagsFromAllNotes();
      
      if (allTags.length === 0) {
        allTagsOverview.innerHTML = '<small class="text-muted">No tags yet. Start adding #hashtags to your notes!</small>';
        return;
      }
      
      allTagsOverview.innerHTML = allTags.map(item => {
        const isSelected = selectedTagFilters.includes(item.tag);
        const tagClass = isSelected ? 'note-tag selected' : 'note-tag';
        
        return `
          <span class="${tagClass}" onclick="toggleTagFilter('${item.tag}')">
            #${item.tag}
            <span class="tag-count">${item.count}</span>
          </span>`;
      }).join('');
    }
    
    function toggleTagFilter(tag) {
      if (selectedTagFilters.includes(tag)) {
        selectedTagFilters = selectedTagFilters.filter(t => t !== tag);
      } else {
        selectedTagFilters.push(tag);
      }
      
      updateTagFilters();
      updateAllTagsOverview();
    }
    
    function updateTagFilters() {
      const notesFilterContainer = document.getElementById('notesFilterContainer');
      const selectedTagsContainer = document.getElementById('selectedTagsContainer');
      
      if (selectedTagFilters.length > 0) {
        notesFilterContainer.style.display = 'flex';
        notesFilterContainer.classList.add('has-filters');
        
        selectedTagsContainer.innerHTML = selectedTagFilters.map(tag => 
          `<span class="note-tag selected" onclick="toggleTagFilter('${tag}')">
             #${tag} <i class="bi bi-x"></i>
           </span>`
        ).join('');
      } else {
        notesFilterContainer.style.display = 'none';
        notesFilterContainer.classList.remove('has-filters');
      }
    }
    
    function clearNotesFilters() {
      selectedTagFilters = [];
      updateTagFilters();
      updateAllTagsOverview();
    }
    
    function showTagAnalytics() {
      const modal = new bootstrap.Modal(document.getElementById('tagAnalyticsModal'));
      updateTagAnalytics();
      modal.show();
    }
    
    function updateTagAnalytics() {
      const allNotes = getAllNotes();
      const allTags = getAllTagsFromAllNotes();
      const categories = categorizeNotesByTags(allNotes);
      
      // Update statistics
      document.getElementById('totalTagsCount').textContent = allTags.length;
      document.getElementById('stocksWithNotesCount').textContent = Object.keys(allNotes).length;
      
      const totalTagInstances = allTags.reduce((sum, item) => sum + item.count, 0);
      const avgTags = Object.keys(allNotes).length > 0 ? (totalTagInstances / Object.keys(allNotes).length).toFixed(1) : '0';
      document.getElementById('avgTagsPerStock').textContent = avgTags;
      
      const mostUsedTag = allTags.length > 0 ? allTags[0].tag : '-';
      document.getElementById('mostUsedTagName').textContent = `#${mostUsedTag}`;
      
      // Update categories
      updateTagCategories(categories);
      
      // Update all tags list
      updateAllTagsList(allTags);
    }
    
    function updateTagCategories(categories) {
      const container = document.getElementById('tagCategoriesContainer');
      
      const categoryHtml = Object.entries(categories).map(([categoryName, subcategories]) => {
        if (categoryName === 'uncategorized') return '';
        
        const subcatHtml = Object.entries(subcategories).map(([subcat, stocks]) => {
          if (stocks.length === 0) return '';
          return `
            <div class="col-md-3 mb-2">
              <div class="card border-0 bg-light">
                <div class="card-body p-2 text-center">
                  <div class="h6 mb-1 text-capitalize">${subcat}</div>
                  <div class="text-muted small">${stocks.length} stocks</div>
                  <div class="small">${stocks.slice(0, 3).join(', ')}${stocks.length > 3 ? '...' : ''}</div>
                </div>
              </div>
            </div>`;
        }).join('');
        
        if (subcatHtml) {
          return `
            <div class="mb-3">
              <h6 class="text-capitalize">${categoryName}</h6>
              <div class="row">
                ${subcatHtml}
              </div>
            </div>`;
        }
        return '';
      }).join('');
      
      container.innerHTML = categoryHtml || '<div class="text-muted">No categorized tags yet. Use tags like #bullish, #buy, #longterm to see categories.</div>';
    }
    
    function updateAllTagsList(allTags) {
      const container = document.getElementById('allTagsList');
      
      if (allTags.length === 0) {
        container.innerHTML = '<div class="text-muted text-center">No tags found</div>';
        return;
      }
      
      const tagsHtml = allTags.map((item, index) => {
        const percentage = allTags.length > 0 ? ((item.count / allTags.reduce((sum, t) => sum + t.count, 0)) * 100).toFixed(1) : 0;
        const stocks = getStocksByTag(item.tag);
        
        return `
          <div class="d-flex justify-content-between align-items-center p-2 border-bottom">
            <div>
              <span class="note-tag">#${item.tag}</span>
              <small class="text-muted ms-2">${stocks.join(', ')}</small>
            </div>
            <div class="text-end">
              <div class="fw-bold">${item.count}</div>
              <small class="text-muted">${percentage}%</small>
            </div>
          </div>`;
      }).join('');
      
      container.innerHTML = tagsHtml;
    }
    
    function exportTagData() {
      const allNotes = getAllNotes();
      const allTags = getAllTagsFromAllNotes();
      const categories = categorizeNotesByTags(allNotes);
      
      const exportData = {
        summary: {
          totalTags: allTags.length,
          totalStocks: Object.keys(allNotes).length,
          exportDate: new Date().toISOString()
        },
        tags: allTags,
        categories: categories,
        stockNotes: Object.entries(allNotes).map(([symbol, notes]) => ({
          symbol,
          notes,
          tags: extractTagsFromText(notes)
        }))
      };
      
      const blob = new Blob([JSON.stringify(exportData, null, 2)], {type: 'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `stock-notes-tags-export-${getCurrentWatchlistName()}.json`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }
    document.addEventListener('DOMContentLoaded', function() {
      // Add Alert form
      const addAlertForm = document.getElementById('addAlertForm');
      if (addAlertForm) {
        addAlertForm.onsubmit = function(e) {
          e.preventDefault();
          const field = document.getElementById('alertField').value;
          const op = document.getElementById('alertOp').value;
          let value = document.getElementById('alertValue').value;
          if (field === 'volume') {
            value = value * 1e6;
          }
          if (currentAlertsSymbol && field && op && value) {
            addAlert(currentAlertsSymbol, field, op, value);
            renderAlertsList(currentAlertsSymbol);
            addAlertForm.reset();
            updateAlertInputDisplay(); // Reset the input display
          }
        };
        // Show appropriate prefix/suffix for different field types
        const alertField = document.getElementById('alertField');
        const alertPrefix = document.getElementById('alertPrefix');
        const alertSuffix = document.getElementById('alertSuffix');
        const alertValue = document.getElementById('alertValue');
        
        function updateAlertInputDisplay() {
          const fieldType = alertField.value;
          
          // Reset display
          alertPrefix.style.display = 'none';
          alertSuffix.style.display = 'none';
          
          if (fieldType === 'price' || fieldType === 'ma50' || fieldType === 'ma200' || fieldType === 'atr14') {
            alertPrefix.style.display = '';
            alertValue.placeholder = '0.00';
          } else if (fieldType === 'volume') {
            alertSuffix.style.display = '';
            alertValue.placeholder = '1.5';
          } else if (fieldType === 'rsi') {
            alertValue.placeholder = '70';
          }
        }
        
        alertField.onchange = updateAlertInputDisplay;
        // Initial state
        updateAlertInputDisplay();
      }
      
      // Notes form
      const notesForm = document.getElementById('notesForm');
      if (notesForm) {
        notesForm.onsubmit = function(e) {
          e.preventDefault();
          if (!currentNotesSymbol) return;
          
          const noteContent = document.getElementById('noteContent').value;
          setNotes(currentNotesSymbol, noteContent);
          
          // Update notes icon in the UI
          updateNotesIcon(currentNotesSymbol);
          
          // Close modal
          const modal = bootstrap.Modal.getInstance(document.getElementById('notesModal'));
          if (modal) modal.hide();
        };
        
        // Clear notes button
        const clearNotesBtn = document.getElementById('clearNotesBtn');
        if (clearNotesBtn) {
          clearNotesBtn.onclick = function() {
            if (confirm('Are you sure you want to clear all notes for this stock?')) {
              document.getElementById('noteContent').value = '';
              clearNotesBtn.style.display = 'none';
            }
          };
        }
        
        // Show/hide clear button based on content
        const noteContent = document.getElementById('noteContent');
        if (noteContent) {
          noteContent.oninput = function() {
            const clearNotesBtn = document.getElementById('clearNotesBtn');
            if (noteContent.value.trim()) {
              clearNotesBtn.style.display = 'inline-block';
            } else {
              clearNotesBtn.style.display = 'none';
            }
          };
        }
      }
    });
    // --- Export/Import logic ---
    document.addEventListener('DOMContentLoaded', function() {
      const exportBtn = document.getElementById('exportBtn');
      const importBtn = document.getElementById('importBtn');
      const importFile = document.getElementById('importFile');

      if (exportBtn) {
        exportBtn.onclick = function() {
          // Gather all relevant data
          const data = {
            trackedStocks: getTrackedStocks(),
            stockWatchlists: getWatchlists(),
            currentDataCache: currentDataCache,
            historicalIndicators: historicalIndicators,
            stockAlerts: getAllAlerts(), // Include user alerts
            stockNotes: getAllNotesForExport(), // Include user notes
            settings: {
              userEmail: localStorage.getItem('userEmail'),
              refreshInterval: localStorage.getItem('refreshInterval'),
              tableView: localStorage.getItem('tableView'),
              darkMode: localStorage.getItem('darkMode'),
              tableSortColumn: localStorage.getItem('tableSortColumn'),
              tableSortDirection: localStorage.getItem('tableSortDirection'),
              currentWatchlist: localStorage.getItem('currentWatchlist'),
              currentViewMode: localStorage.getItem('currentViewMode')
            },
            // Include cache timestamps for data freshness
            cacheTimestamps: {
              stockCurrentDataTimestamp: localStorage.getItem('stockCurrentDataTimestamp'),
              stockHistoricalDataTimestamp: localStorage.getItem('stockHistoricalDataTimestamp')
            }
          };
          const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'stock-tracker-export.json';
          document.body.appendChild(a);
          a.click();
          setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          }, 100);
        };
      }

      if (importBtn && importFile) {
        importBtn.onclick = function() {
          importFile.value = '';
          importFile.click();
        };
        importFile.onchange = function(e) {
          const file = e.target.files[0];
          if (!file) return;
          const reader = new FileReader();
          reader.onload = function(evt) {
            try {
              const data = JSON.parse(evt.target.result);
              if (!data.trackedStocks && !data.stockWatchlists) throw new Error('Invalid file - no stock data found');
              
              // Clear all localStorage keys used by the app
              localStorage.clear();
              
              // Restore watchlists (new format) or stocks (legacy format)
              if (data.stockWatchlists && Array.isArray(data.stockWatchlists)) {
                localStorage.setItem('stockWatchlists', JSON.stringify(data.stockWatchlists));
              } else if (data.trackedStocks && Array.isArray(data.trackedStocks)) {
                // Legacy format - convert to watchlist
                const mainWatchlist = { name: 'Main', stocks: data.trackedStocks };
                localStorage.setItem('stockWatchlists', JSON.stringify([mainWatchlist]));
                localStorage.setItem('currentWatchlist', 'Main');
              }
              
              // Restore settings
              if (data.settings) {
                Object.entries(data.settings).forEach(([k,v]) => {
                  if (v !== undefined && v !== null) localStorage.setItem(k, v);
                });
              }
              
              // Restore user alerts
              if (data.stockAlerts) {
                localStorage.setItem('stockAlerts', JSON.stringify(data.stockAlerts));
              }
              
              // Restore user notes
              if (data.stockNotes) {
                Object.entries(data.stockNotes).forEach(([watchlistName, notes]) => {
                  const notesKey = `stockNotes_${watchlistName}`;
                  localStorage.setItem(notesKey, JSON.stringify(notes));
                });
              }
              
              // Restore caches
              if (data.currentDataCache) localStorage.setItem('stockCurrentData', JSON.stringify(data.currentDataCache));
              if (data.historicalIndicators) localStorage.setItem('stockHistoricalData', JSON.stringify(data.historicalIndicators));
              
              // Restore cache timestamps
              if (data.cacheTimestamps) {
                Object.entries(data.cacheTimestamps).forEach(([k,v]) => {
                  if (v !== undefined && v !== null) localStorage.setItem(k, v);
                });
              }
              
              // Reload the page to apply everything
              location.reload();
            } catch (err) {
              alert('Import failed: ' + err.message);
            }
          };
          reader.readAsText(file);
        };
      }
    });
  </script>
    <div class="stock-list row g-3" id="stockList"></div>
    <div class="loading" id="loading" style="display:none;">Loading data...</div>
    <!-- Alerts Modal -->
    <div class="modal fade alert-list-modal" id="alertsModal" tabindex="-1" aria-labelledby="alertsModalLabel" aria-hidden="true">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="alertsModalLabel">Alerts for <span id="alertsModalSymbol"></span></h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <ul class="alert-list" id="alertsList"></ul>
            <hr/>
            <div class="mb-2"><b>Add Alert</b></div>
            <form id="addAlertForm">
              <div class="row g-2 align-items-center">
                <div class="col-5">
                  <select class="form-select" id="alertField" required>
                    <option value="price">Price</option>
                    <option value="rsi">RSI(14)</option>
                    <option value="ma50">50-day Avg</option>
                    <option value="ma200">200-day Avg</option>
                    <option value="atr14">ATR(14)</option>
                    <option value="volume">Volume (M)</option>
                  </select>
                </div>
                <div class="col-2">
                  <select class="form-select" id="alertOp" required>
                    <option value=">">&gt;</option>
                    <option value="<">&lt;</option>
                    <option value="=">=</option>
                  </select>
                </div>
                <div class="col-5 d-flex align-items-center" id="alertValueWrapper">
                  <div class="input-group">
                    <span class="input-group-text" id="alertPrefix" style="display:none;">$</span>
                    <input type="number" class="form-control" id="alertValue" required step="any" placeholder="Value">
                    <span class="input-group-text" id="alertSuffix" style="display:none;">M</span>
                  </div>
                </div>
              </div>
              <button type="submit" class="btn btn-primary btn-sm mt-2 w-100">Add Alert</button>
            </form>
          </div>
        </div>
      </div>
    </div>

    <!-- Watchlist Management Modal -->
    <div class="modal fade" id="watchlistModal" tabindex="-1" aria-labelledby="watchlistModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="watchlistModalLabel">Watchlist Management</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <!-- Create New Watchlist -->
            <div class="mb-4">
              <h6>Create New Watchlist</h6>
              <div class="row g-2">
                <div class="col-8">
                  <input type="text" id="newWatchlistName" class="form-control" placeholder="Enter watchlist name" maxlength="30">
                </div>
                <div class="col-4">
                  <button class="btn btn-primary w-100" onclick="createNewWatchlist()">Create</button>
                </div>
              </div>
              
              <!-- Quick Create from Predefined -->
              <div class="mt-3">
                <small class="text-muted">Quick create from predefined:</small>
                <div class="d-flex flex-wrap gap-1 mt-1">
                  <small class="fw-bold text-muted">Sectors:</small>
                  <div class="d-flex flex-wrap gap-1">
                    <button class="btn btn-sm btn-outline-primary" onclick="createPredefinedWatchlist('Technology')">Technology</button>
                    <button class="btn btn-sm btn-outline-primary" onclick="createPredefinedWatchlist('Healthcare')">Healthcare</button>
                    <button class="btn btn-sm btn-outline-primary" onclick="createPredefinedWatchlist('Financial')">Financial</button>
                    <button class="btn btn-sm btn-outline-primary" onclick="createPredefinedWatchlist('Energy')">Energy</button>
                  </div>
                </div>
                <div class="d-flex flex-wrap gap-1 mt-2">
                  <small class="fw-bold text-muted">Strategies:</small>
                  <div class="d-flex flex-wrap gap-1">
                    <button class="btn btn-sm btn-outline-success" onclick="createPredefinedWatchlist('Growth')">Growth</button>
                    <button class="btn btn-sm btn-outline-success" onclick="createPredefinedWatchlist('Value')">Value</button>
                    <button class="btn btn-sm btn-outline-success" onclick="createPredefinedWatchlist('Dividend')">Dividend</button>
                    <button class="btn btn-sm btn-outline-success" onclick="createPredefinedWatchlist('High Volatility')">High Vol</button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Manage Existing Watchlists -->
            <div>
              <h6>Manage Existing Watchlists</h6>
              <div id="watchlistManagementList">
                <!-- Will be populated by JavaScript -->
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Notes Modal -->
    <div class="modal fade" id="notesModal" tabindex="-1" aria-labelledby="notesModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="notesModalLabel">
              <i class="bi bi-sticky me-2"></i>Notes for <span id="notesModalSymbol"></span>
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <!-- Tags Filter and Search -->
            <div class="notes-filter-container" id="notesFilterContainer" style="display:none;">
              <small class="text-muted me-2">Filter by tags:</small>
              <div id="selectedTagsContainer" class="d-flex flex-wrap gap-1"></div>
              <button type="button" class="btn btn-sm btn-outline-secondary ms-auto" onclick="clearNotesFilters()">
                <i class="bi bi-x-circle"></i> Clear Filters
              </button>
            </div>
            
            <form id="notesForm">
              <div class="mb-3">
                <label for="noteContent" class="form-label">
                  Your Notes 
                  <small class="text-muted">(Use #hashtags to organize)</small>
                </label>
                <div class="tag-input-container">
                  <textarea 
                    class="form-control notes-textarea" 
                    id="noteContent" 
                    rows="6" 
                    placeholder="Examples:
• Watching for #breakout above $150 #bullish
• Strong #earnings expected next quarter #buy
• Consider adding on dip to $145 #opportunity
• #stoploss at $140 #risk

Use #hashtags to organize your notes by:
• Sentiment: #bullish #bearish #neutral
• Actions: #buy #sell #hold #watch
• Analysis: #technical #fundamental #news
• Timeframe: #longterm #shortterm #swing"></textarea>
                  <div class="tag-suggestions" id="tagSuggestions"></div>
                </div>
                <div class="form-text">
                  <i class="bi bi-lightbulb me-1"></i>
                  <strong>Pro tip:</strong> Use hashtags like #bullish, #earnings, #breakout to categorize and filter your notes across all stocks.
                </div>
              </div>
              
              <!-- Current Tags Display -->
              <div class="mb-3" id="currentTagsContainer" style="display:none;">
                <label class="form-label">Tags in this note:</label>
                <div id="currentTags" class="d-flex flex-wrap gap-1"></div>
              </div>
              
              <!-- Quick Tag Buttons -->
              <div class="mb-3">
                <label class="form-label">Quick tags:</label>
                <div class="d-flex flex-wrap gap-1" id="quickTagButtons">
                  <!-- Will be populated by JavaScript -->
                </div>
              </div>
              
              <div class="d-flex justify-content-between">
                <button type="button" class="btn btn-outline-danger" id="clearNotesBtn" style="display:none;">
                  <i class="bi bi-trash"></i> Clear Notes
                </button>
                <div class="ms-auto">
                  <button type="button" class="btn btn-secondary me-2" data-bs-dismiss="modal">Cancel</button>
                  <button type="submit" class="btn btn-primary">
                    <i class="bi bi-check-lg"></i> Save Notes
                  </button>
                </div>
              </div>
            </form>
          </div>
          <div class="modal-footer border-0 pt-0">
            <!-- All Tags Overview -->
            <div class="w-100">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <small class="text-muted">All tags in this watchlist:</small>
                <button type="button" class="btn btn-sm btn-outline-primary" onclick="showTagAnalytics()">
                  <i class="bi bi-bar-chart"></i> Tag Analytics
                </button>
              </div>
              <div id="allTagsOverview" class="d-flex flex-wrap gap-1" style="max-height: 80px; overflow-y: auto;">
                <!-- Will be populated by JavaScript -->
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tag Analytics Modal -->
    <div class="modal fade" id="tagAnalyticsModal" tabindex="-1" aria-labelledby="tagAnalyticsModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="tagAnalyticsModalLabel">
              <i class="bi bi-bar-chart me-2"></i>Tag Analytics
            </h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <!-- Tag Statistics -->
            <div class="row mb-4">
              <div class="col-md-3">
                <div class="text-center">
                  <div class="h3 text-primary" id="totalTagsCount">0</div>
                  <div class="text-muted">Total Tags</div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="text-center">
                  <div class="h3 text-success" id="stocksWithNotesCount">0</div>
                  <div class="text-muted">Stocks with Notes</div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="text-center">
                  <div class="h3 text-info" id="avgTagsPerStock">0</div>
                  <div class="text-muted">Avg Tags/Stock</div>
                </div>
              </div>
              <div class="col-md-3">
                <div class="text-center">
                  <div class="h3 text-warning" id="mostUsedTagName">-</div>
                  <div class="text-muted">Most Used Tag</div>
                </div>
              </div>
            </div>
            
            <!-- Tag Categories -->
            <div class="mb-4">
              <h6>Categories</h6>
              <div id="tagCategoriesContainer">
                <!-- Will be populated by JavaScript -->
              </div>
            </div>
            
            <!-- Top Tags List -->
            <div class="mb-4">
              <h6>All Tags (by frequency)</h6>
              <div id="allTagsList" class="border rounded p-3" style="max-height: 300px; overflow-y: auto;">
                <!-- Will be populated by JavaScript -->
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-outline-primary" onclick="exportTagData()">
              <i class="bi bi-download"></i> Export Tag Data
            </button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // --- Technical Indicator Trend Analysis ---
    function getTrendIndicator(current, previous, type = 'default') {
      if (current === null || current === undefined || previous === null || previous === undefined) {
        return { direction: '', class: 'neutral', symbol: '' };
      }
      
      const diff = current - previous;
      const threshold = type === 'rsi' ? 1 : (type === 'cci' ? 5 : 0.01); // Minimum change thresholds
      
      if (Math.abs(diff) < threshold) {
        return { direction: 'sideways', class: 'neutral', symbol: '' };
      }
      
      if (diff > 0) {
        return { direction: 'up', class: 'up', symbol: '▲' };
      } else {
        return { direction: 'down', class: 'down', symbol: '▼' };
      }
    }
    
    function getMovingAverageTrend(price, ma) {
      if (!price || !ma) {
        return { direction: '', class: 'neutral', symbol: '', text: '' };
      }
      
      const diff = price - ma;
      const pctDiff = (diff / ma) * 100;
      
      if (Math.abs(pctDiff) < 0.5) {
        return { direction: 'neutral', class: 'neutral', symbol: '', text: 'At MA' };
      }
      
      if (price > ma) {
        return { direction: 'above', class: 'up', symbol: '▲', text: 'Above' };
      } else {
        return { direction: 'below', class: 'down', symbol: '▼', text: 'Below' };
      }
    }
    
    function getRSITrend(rsi, previousRSI) {
      const trend = getTrendIndicator(rsi, previousRSI, 'rsi');
      let condition = '';
      
      if (rsi >= 70) {
        condition = 'Overbought';
      } else if (rsi <= 30) {
        condition = 'Oversold';
      } else if (rsi >= 60) {
        condition = 'Strong';
      } else if (rsi <= 40) {
        condition = 'Weak';
      } else {
        condition = 'Neutral';
      }
      
      return { ...trend, condition };
    }
    
    function getCCITrend(cci, previousCCI) {
      const trend = getTrendIndicator(cci, previousCCI, 'cci');
      let condition = '';
      
      if (cci >= 100) {
        condition = 'Overbought';
      } else if (cci <= -100) {
        condition = 'Oversold';
      } else if (cci >= 50) {
        condition = 'Bullish';
      } else if (cci <= -50) {
        condition = 'Bearish';
      } else {
        condition = 'Neutral';
      }
      
      return { ...trend, condition };
    }

    // --- Advanced Technical Indicators for Smart Score ---
    
    // Calculate Bollinger Bands (20-period, 2 std dev)
    function calculateBollingerBands(closes) {
      if (!closes || closes.length < 20) return null;
      
      const period = 20;
      const stdDevMultiplier = 2;
      const validCloses = closes.slice(-period).filter(c => c !== null && !isNaN(c));
      
      if (validCloses.length < period) return null;
      
      // Calculate Simple Moving Average (middle band)
      const sma = validCloses.reduce((sum, close) => sum + close, 0) / validCloses.length;
      
      // Calculate Standard Deviation
      const variance = validCloses.reduce((sum, close) => sum + Math.pow(close - sma, 2), 0) / validCloses.length;
      const stdDev = Math.sqrt(variance);
      
      // Calculate bands
      const upperBand = sma + (stdDev * stdDevMultiplier);
      const lowerBand = sma - (stdDev * stdDevMultiplier);
      
      return {
        upper: upperBand,
        middle: sma,
        lower: lowerBand,
        stdDev: stdDev,
        bandwidth: ((upperBand - lowerBand) / sma) * 100 // Bandwidth percentage
      };
    }
    
    // Calculate MACD (12, 26, 9)
    function calculateMACD(closes) {
      if (!closes || closes.length < 35) return null; // Need at least 35 periods for MACD
      
      const fastPeriod = 12;
      const slowPeriod = 26;
      const signalPeriod = 9;
      
      // Calculate EMAs
      const fastEMA = calculateEMA(closes, fastPeriod);
      const slowEMA = calculateEMA(closes, slowPeriod);
      
      if (!fastEMA || !slowEMA) return null;
      
      // MACD Line = Fast EMA - Slow EMA
      const macdLine = fastEMA - slowEMA;
      
      // Signal Line = EMA of MACD Line
      const macdHistory = [];
      for (let i = slowPeriod - 1; i < closes.length; i++) {
        const fastEMAval = calculateEMA(closes.slice(0, i + 1), fastPeriod);
        const slowEMAval = calculateEMA(closes.slice(0, i + 1), slowPeriod);
        if (fastEMAval && slowEMAval) {
          macdHistory.push(fastEMAval - slowEMAval);
        }
      }
      
      const signalLine = calculateEMA(macdHistory, signalPeriod);
      
      // Histogram = MACD Line - Signal Line
      const histogram = signalLine ? macdLine - signalLine : 0;
      
      return {
        macd: macdLine,
        signal: signalLine || 0,
        histogram: histogram,
        divergence: macdLine > signalLine ? 'bullish' : 'bearish'
      };
    }
    
    // Calculate Exponential Moving Average
    function calculateEMA(data, period) {
      if (!data || data.length < period) return null;
      
      const validData = data.filter(d => d !== null && !isNaN(d));
      if (validData.length < period) return null;
      
      const multiplier = 2 / (period + 1);
      let ema = validData.slice(0, period).reduce((sum, val) => sum + val, 0) / period;
      
      for (let i = period; i < validData.length; i++) {
        ema = (validData[i] * multiplier) + (ema * (1 - multiplier));
      }
      
      return ema;
    }
    
    // Generate Bollinger Bands signals
    function getBollingerSignal(price, bollingerBands) {
      if (!price || !bollingerBands) return { signal: 'neutral', strength: 0, reason: '' };
      
      const { upper, middle, lower, bandwidth } = bollingerBands;
      const upperDistance = ((price - upper) / upper) * 100;
      const lowerDistance = ((lower - price) / lower) * 100;
      const middleDistance = ((price - middle) / middle) * 100;
      
      // Strong signals when price touches bands
      if (price <= lower) {
        const strength = Math.min(100, Math.abs(lowerDistance) * 20); // Max 100%
        return {
          signal: 'strong_buy',
          strength: strength,
          reason: `Price at lower band (${lowerDistance.toFixed(1)}% below)`
        };
      }
      
      if (price >= upper) {
        const strength = Math.min(100, Math.abs(upperDistance) * 20);
        return {
          signal: 'strong_sell',
          strength: strength,
          reason: `Price at upper band (${upperDistance.toFixed(1)}% above)`
        };
      }
      
      // Moderate signals based on position within bands
      if (price < middle) {
        const strength = Math.abs(middleDistance) * 10;
        return {
          signal: 'buy',
          strength: Math.min(70, strength),
          reason: `Below middle band (${middleDistance.toFixed(1)}%)`
        };
      }
      
      if (price > middle) {
        const strength = Math.abs(middleDistance) * 10;
        return {
          signal: 'sell',
          strength: Math.min(70, strength),
          reason: `Above middle band (${middleDistance.toFixed(1)}%)`
        };
      }
      
      return { signal: 'neutral', strength: 0, reason: 'At middle band' };
    }
    
    // Generate MACD signals
    function getMACDSignal(macdData, previousMACDData) {
      if (!macdData) return { signal: 'neutral', strength: 0, reason: '' };
      
      const { macd, signal, histogram, divergence } = macdData;
      let signalType = 'neutral';
      let strength = 0;
      let reason = '';
      
      // Signal line crossover (strongest signal)
      if (previousMACDData) {
        const prevDivergence = previousMACDData.divergence;
        if (divergence === 'bullish' && prevDivergence === 'bearish') {
          strength = 90;
          signalType = 'strong_buy';
          reason = 'MACD bullish crossover';
        } else if (divergence === 'bearish' && prevDivergence === 'bullish') {
          strength = 90;
          signalType = 'strong_sell';
          reason = 'MACD bearish crossover';
        }
      }
      
      // Zero line crossover
      if (strength === 0) {
        if (macd > 0 && signal > 0) {
          strength = 60;
          signalType = 'buy';
          reason = 'MACD above zero line';
        } else if (macd < 0 && signal < 0) {
          strength = 60;
          signalType = 'sell';
          reason = 'MACD below zero line';
        }
      }
      
      // Histogram momentum
      if (strength === 0) {
        const histogramStrength = Math.min(50, Math.abs(histogram) * 100);
        if (histogram > 0.02) {
          strength = histogramStrength;
          signalType = 'buy';
          reason = 'MACD histogram positive';
        } else if (histogram < -0.02) {
          strength = histogramStrength;
          signalType = 'sell';
          reason = 'MACD histogram negative';
        }
      }
      
      return { signal: signalType, strength, reason };
    }
    
    // Generate RSI signals
    function getRSISignal(rsi, previousRSI) {
      if (!rsi) return { signal: 'neutral', strength: 0, reason: '' };
      
      let signalType = 'neutral';
      let strength = 0;
      let reason = '';
      
      // Strong signals for extreme RSI levels
      if (rsi <= 20) {
        strength = 85; // Very oversold
        signalType = 'strong_buy';
        reason = `RSI severely oversold (${rsi.toFixed(1)})`;
      } else if (rsi <= 30) {
        strength = 70; // Oversold
        signalType = 'buy';
        reason = `RSI oversold (${rsi.toFixed(1)})`;
      } else if (rsi >= 80) {
        strength = 85; // Very overbought
        signalType = 'strong_sell';
        reason = `RSI severely overbought (${rsi.toFixed(1)})`;
      } else if (rsi >= 70) {
        strength = 70; // Overbought
        signalType = 'sell';
        reason = `RSI overbought (${rsi.toFixed(1)})`;
      }
      
      // RSI momentum signals (if we have previous RSI)
      if (strength === 0 && previousRSI) {
        const rsiChange = rsi - previousRSI;
        
        // Bullish divergence detection (simplified)
        if (rsi < 40 && rsiChange > 5) {
          strength = 50;
          signalType = 'buy';
          reason = `RSI bullish momentum (${rsi.toFixed(1)}, +${rsiChange.toFixed(1)})`;
        } else if (rsi > 60 && rsiChange < -5) {
          strength = 50;
          signalType = 'sell';
          reason = `RSI bearish momentum (${rsi.toFixed(1)}, ${rsiChange.toFixed(1)})`;
        }
      }
      
      return { signal: signalType, strength, reason };
    }
    
    // Generate volume confirmation signals
    function getVolumeSignal(volume, avgVolume, priceDir, volDir) {
      if (!volume || !avgVolume || !priceDir || !volDir) {
        return { signal: 'neutral', strength: 0, reason: '' };
      }
      
      const volumeRatio = volume / avgVolume;
      let signalType = 'neutral';
      let strength = 0;
      let reason = '';
      
      // Volume confirmation for price movements
      if (priceDir === 'up' && volDir === 'up' && volumeRatio > 1.5) {
        strength = Math.min(80, volumeRatio * 30); // Cap at 80%
        signalType = 'buy';
        reason = `Strong volume confirmation (${volumeRatio.toFixed(1)}x avg)`;
      } else if (priceDir === 'down' && volDir === 'up' && volumeRatio > 1.5) {
        strength = Math.min(80, volumeRatio * 30);
        signalType = 'sell';
        reason = `High volume decline (${volumeRatio.toFixed(1)}x avg)`;
      }
      
      // Volume divergence signals
      if (strength === 0) {
        if (priceDir === 'up' && volDir === 'down' && volumeRatio < 0.7) {
          strength = 40;
          signalType = 'sell';
          reason = `Volume divergence - price up, volume down`;
        } else if (priceDir === 'down' && volDir === 'down' && volumeRatio < 0.7) {
          strength = 30;
          signalType = 'buy';
          reason = `Low volume decline - lack of selling pressure`;
        }
      }
      
      return { signal: signalType, strength, reason };
    }
    
    // Generate trend confirmation signals using multiple MAs
    function getTrendSignal(price, ma50, ma150, ma200) {
      if (!price || !ma50 || !ma150 || !ma200) {
        return { signal: 'neutral', strength: 0, reason: '' };
      }
      
      let signalType = 'neutral';
      let strength = 0;
      let reason = '';
      
      // Check MA alignment (strongest trend signal)
      const isUptrend = ma50 > ma150 && ma150 > ma200 && price > ma50;
      const isDowntrend = ma50 < ma150 && ma150 < ma200 && price < ma50;
      
      if (isUptrend) {
        strength = 60;
        signalType = 'buy';
        reason = 'Strong uptrend - all MAs aligned';
      } else if (isDowntrend) {
        strength = 60;
        signalType = 'sell';
        reason = 'Strong downtrend - all MAs aligned';
      }
      
      // MA crossover signals
      if (strength === 0) {
        const ma50_vs_ma200 = ((ma50 - ma200) / ma200) * 100;
        
        if (price > ma50 && ma50 > ma200 && ma50_vs_ma200 > 2) {
          strength = 45;
          signalType = 'buy';
          reason = 'Above key MAs - bullish trend';
        } else if (price < ma50 && ma50 < ma200 && ma50_vs_ma200 < -2) {
          strength = 45;
          signalType = 'sell';
          reason = 'Below key MAs - bearish trend';
        }
      }
      
      return { signal: signalType, strength, reason };
    }
    
    // Calculate Smart Score (0-100)
    function calculateSmartScore(signals) {
      if (!signals || signals.length === 0) return { score: 50, sentiment: 'neutral', confidence: 'low', signals: [] };
      
      let totalScore = 0;
      let totalWeight = 0;
      const weights = { 
        strong_buy: 1.0, buy: 0.6, neutral: 0.0, sell: -0.6, strong_sell: -1.0 
      };
      
      const processedSignals = signals.map(signal => {
        const weight = weights[signal.signal] || 0;
        const weightedScore = weight * (signal.strength / 100);
        totalScore += weightedScore;
        totalWeight += Math.abs(weight);
        
        return {
          ...signal,
          weight: weight,
          weightedScore: weightedScore
        };
      });
      
      // Normalize to 0-100 scale (50 = neutral)
      const normalizedScore = totalWeight > 0 ? 50 + (totalScore / totalWeight) * 50 : 50;
      const finalScore = Math.max(0, Math.min(100, normalizedScore));
      
      // Determine sentiment and confidence
      let sentiment = 'neutral';
      let confidence = 'low';
      
      if (finalScore >= 70) {
        sentiment = 'bullish';
        confidence = finalScore >= 85 ? 'high' : 'medium';
      } else if (finalScore <= 30) {
        sentiment = 'bearish';
        confidence = finalScore <= 15 ? 'high' : 'medium';
      } else if (finalScore >= 55 || finalScore <= 45) {
        confidence = 'medium';
      }
      
      return {
        score: Math.round(finalScore),
        sentiment,
        confidence,
        signals: processedSignals,
        totalSignals: signals.length
      };
    }
    
    // Format number to human-readable (e.g., 29.5M)
    function humanVolume(num) {
      if (num == null || isNaN(num)) return '-';
      if (num >= 1e9) return (num / 1e9).toFixed(2).replace(/\.00$/, '') + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(2).replace(/\.00$/, '') + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(2).replace(/\.00$/, '') + 'K';
      return num.toString();
    }
    // --- Config ---
    const API_KEY = '';
    // Use allorigins CORS proxy for Yahoo Finance
    const YF_URL = (symbol, range = '200d') => {
      const ts = Date.now();
      return `https://api.allorigins.win/get?url=${encodeURIComponent('https://query1.finance.yahoo.com/v8/finance/chart/' + symbol + '?interval=1d&range=' + range + '&_=' + ts)}`;
    };
    
    // Yahoo Finance Search API for autocomplete
    const YF_SEARCH_URL = (query) => {
      return `https://api.allorigins.win/get?url=${encodeURIComponent('https://query1.finance.yahoo.com/v1/finance/search?q=' + encodeURIComponent(query) + '&lang=en-US&region=US&quotesCount=10&newsCount=0')}`;
    };
    
    // CBOE Listed Symbols CSV for comprehensive fallback
    const CBOE_SYMBOLS_URL = 'https://www.cboe.com/us/equities/market_statistics/listed_symbols/csv';
    
    // Local symbol cache for offline/fallback search
    let symbolCache = null;
    let cacheTimestamp = null;
    const SYMBOL_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours
    // ---

    // Local storage helpers - Watchlist aware
    function getWatchlists() {
      const watchlists = JSON.parse(localStorage.getItem('stockWatchlists') || '[]');
      // Migration: If empty but old trackedStocks exists, migrate
      if (watchlists.length === 0) {
        const oldStocks = JSON.parse(localStorage.getItem('trackedStocks') || '[]');
        if (oldStocks.length > 0) {
          const mainWatchlist = { name: 'Main', stocks: oldStocks };
          setWatchlists([mainWatchlist]);
          setCurrentWatchlistName('Main');
          console.log('Migrated', oldStocks.length, 'stocks to Main watchlist');
          return [mainWatchlist];
        }
      }
      return watchlists;
    }
    
    function setWatchlists(watchlists) {
      localStorage.setItem('stockWatchlists', JSON.stringify(watchlists));
    }
    
    function getCurrentWatchlistName() {
      return localStorage.getItem('currentWatchlist') || 'Main';
    }
    
    function setCurrentWatchlistName(name) {
      localStorage.setItem('currentWatchlist', name);
    }
    
    function getTrackedStocks() {
      const watchlists = getWatchlists();
      const currentName = getCurrentWatchlistName();
      const currentWatchlist = watchlists.find(w => w.name === currentName);
      return currentWatchlist ? currentWatchlist.stocks : [];
    }
    
    function setTrackedStocks(stocks) {
      const watchlists = getWatchlists();
      const currentName = getCurrentWatchlistName();
      const currentIndex = watchlists.findIndex(w => w.name === currentName);
      
      if (currentIndex >= 0) {
        watchlists[currentIndex].stocks = stocks;
      } else {
        // Create watchlist if it doesn't exist
        watchlists.push({ name: currentName, stocks: stocks });
      }
      
      setWatchlists(watchlists);
    }
    
    // Predefined sectors and strategies
    const PREDEFINED_SECTORS = [
      'Technology', 'Healthcare', 'Financial', 'Consumer Discretionary', 
      'Communication Services', 'Industrials', 'Energy', 'Materials', 
      'Consumer Staples', 'Utilities', 'Real Estate'
    ];
    
    const PREDEFINED_STRATEGIES = [
      'Growth', 'Value', 'Dividend', 'Momentum', 'High Volatility', 
      'Low Volatility', 'Small Cap', 'Large Cap', 'International'
    ];
    
    // Major market indexes - fixed list
    const MAJOR_INDEXES = [
      '^GSPC',   // S&P 500
      '^DJI',    // Dow Jones Industrial Average
      '^IXIC',   // NASDAQ Composite
      '^RUT',    // Russell 2000
      '^VIX',    // Volatility Index
      '^TNX',    // 10-Year Treasury Yield
      '^FTSE',   // FTSE 100
      '^GDAXI',  // DAX
      '^N225',   // Nikkei 225
      'GC=F',    // Gold Futures
      'CL=F',    // Crude Oil Futures
      'BTC-USD'  // Bitcoin
    ];
    
    // Index display names mapping
    const INDEX_NAMES = {
      '^GSPC': 'S&P 500',
      '^DJI': 'Dow Jones',
      '^IXIC': 'NASDAQ',
      '^RUT': 'Russell 2000',
      '^VIX': 'VIX',
      '^TNX': '10Y Treasury',
      '^FTSE': 'FTSE 100',
      '^GDAXI': 'DAX',
      '^N225': 'Nikkei 225',
      'GC=F': 'Gold',
      'CL=F': 'Crude Oil',
      'BTC-USD': 'Bitcoin'
    };
    
    // Current view mode
    let currentViewMode = localStorage.getItem('currentViewMode') || 'watchlist'; // 'watchlist', 'indexes', or 'news'
    
    // Watchlist management functions
    function renderWatchlistTabs() {
      const tabsContainer = document.getElementById('watchlistTabs');
      const mobileDropdownMenu = document.getElementById('mobileTabDropdownMenu');
      const mobileActiveTabText = document.getElementById('mobileActiveTabText');
      const mobileNewsTab = document.getElementById('mobile-news-tab');
      
      if (!tabsContainer) return;
      
      const watchlists = getWatchlists();
      const currentName = getCurrentWatchlistName();
      
      // Ensure we have at least one watchlist
      if (watchlists.length === 0) {
        const mainWatchlist = { name: 'Main', stocks: [] };
        setWatchlists([mainWatchlist]);
        setCurrentWatchlistName('Main');
        watchlists.push(mainWatchlist);
      }
      
      // --- DESKTOP TABS ---
      let tabsHtml = '';
      
      // Add Indexes tab first (always present)
      const isIndexesActive = currentViewMode === 'indexes';
      tabsHtml += `
        <li class="nav-item" role="presentation">
          <button class="nav-link ${isIndexesActive ? 'active' : ''}" 
                  id="indexes-tab" 
                  data-bs-toggle="tab" 
                  data-bs-target="#indexes-content" 
                  type="button" 
                  role="tab" 
                  onclick="switchToIndexes()"
                  title="Major market indexes">
            <i class="bi bi-graph-up-arrow me-1"></i>Indexes
          </button>
        </li>`;
      
      // Add watchlist tabs
      watchlists.forEach(watchlist => {
        const isActive = watchlist.name === currentName && currentViewMode === 'watchlist';
        const stockCount = watchlist.stocks.length;
        tabsHtml += `
          <li class="nav-item" role="presentation">
            <button class="nav-link ${isActive ? 'active' : ''}" 
                    id="${watchlist.name}-tab" 
                    data-bs-toggle="tab" 
                    data-bs-target="#${watchlist.name}-content" 
                    type="button" 
                    role="tab" 
                    onclick="switchWatchlist('${watchlist.name}')"
                    oncontextmenu="showWatchlistContextMenu(event, '${watchlist.name}'); return false;"
                    title="${stockCount} stocks in ${watchlist.name} (right-click for options)">
              ${watchlist.name} <span class="badge bg-secondary ms-1">${stockCount}</span>
            </button>
          </li>`;
      });
      
      // Add "+" button for new watchlist (right after stock tabs)
      tabsHtml += `
        <li class="nav-item" role="presentation">
          <button class="nav-link" type="button" onclick="showAddWatchlistModal()" title="Add new watchlist">
            <i class="bi bi-plus-lg"></i>
          </button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" type="button" onclick="showAddWatchlistModal()" title="Manage watchlists">
            <i class="bi bi-gear-fill"></i>
          </button>
        </li>`;
      
      // Add news tab on the far right (separated from stock tabs)
      tabsHtml += `
        <li class="nav-item ms-auto" role="presentation">
          <button class="nav-link ${currentViewMode === 'news' ? 'active' : ''}" 
                  id="news-tab" 
                  data-bs-toggle="tab" 
                  data-bs-target="#news-content" 
                  type="button" 
                  role="tab" 
                  onclick="switchToNews()"
                  title="Latest stock market news">
            <i class="bi bi-newspaper me-1"></i>News
          </button>
        </li>`;
      
      tabsContainer.innerHTML = tabsHtml;
      
      // --- MOBILE DROPDOWN ---
      if (mobileDropdownMenu && mobileActiveTabText && mobileNewsTab) {
        let dropdownHtml = '';
        let activeTabText = '';
        
        // Add Indexes to dropdown
        const indexIcon = '<i class="bi bi-graph-up-arrow me-2"></i>';
        if (isIndexesActive) {
          activeTabText = `${indexIcon}Indexes`;
        }
        dropdownHtml += `
          <li><a class="dropdown-item ${isIndexesActive ? 'active' : ''}" href="#" onclick="switchToIndexes(); return false;">
            ${indexIcon}Indexes
          </a></li>`;
        
        // Add watchlists to dropdown
        watchlists.forEach(watchlist => {
          const isActive = watchlist.name === currentName && currentViewMode === 'watchlist';
          const stockCount = watchlist.stocks.length;
          const watchlistIcon = '<i class="bi bi-list-ul me-2"></i>';
          const displayText = `${watchlistIcon}${watchlist.name} (${stockCount})`;
          
          if (isActive) {
            activeTabText = displayText;
          }
          
          dropdownHtml += `
            <li><a class="dropdown-item ${isActive ? 'active' : ''}" href="#" onclick="switchWatchlist('${watchlist.name}'); return false;">
              ${displayText}
            </a></li>`;
        });
        
        // Add separator and manage option
        dropdownHtml += `
          <li><hr class="dropdown-divider"></li>
          <li><a class="dropdown-item" href="#" onclick="showAddWatchlistModal(); return false;">
            <i class="bi bi-plus-lg me-2"></i>Add New Watchlist
          </a></li>`;
        
        mobileDropdownMenu.innerHTML = dropdownHtml;
        mobileActiveTabText.innerHTML = activeTabText || `${indexIcon}Indexes`;
        
        // Update mobile news tab active state
        if (currentViewMode === 'news') {
          mobileNewsTab.classList.add('active');
        } else {
          mobileNewsTab.classList.remove('active');
        }
      }
    }
    
    function switchWatchlist(name) {
      currentViewMode = 'watchlist';
      localStorage.setItem('currentViewMode', currentViewMode);
      setCurrentWatchlistName(name);
      
      // Update tabs to reflect active state change
      renderWatchlistTabs();
      renderStocks();
    }
    
    function switchToIndexes() {
      currentViewMode = 'indexes';
      localStorage.setItem('currentViewMode', currentViewMode);
      
      // Update tabs to reflect active state change
      renderWatchlistTabs();
      renderIndexes();
    }
    
    function switchToNews() {
      currentViewMode = 'news';
      localStorage.setItem('currentViewMode', currentViewMode);
      
      // Update tabs to reflect active state change
      renderWatchlistTabs();
      renderNews();
    }
    
    // Render market indexes
    async function renderIndexes() {
      stockList.innerHTML = '';
      loading.style.display = 'block';
      
      // Always use card view for indexes (no table view)
      stockList.innerHTML = '<div class="row" id="indexGrid"></div>';
      
      // Render all indexes with cached data or placeholders
      MAJOR_INDEXES.forEach(symbol => {
        const indexName = INDEX_NAMES[symbol] || symbol;
        const cachedData = currentDataCache[symbol] || null;
        renderIndexCard(symbol, indexName, cachedData);
      });
      
      loading.style.display = 'none';
      
      // Only fetch data for indexes that don't have valid cached data
      const symbolsToFetch = MAJOR_INDEXES.filter(symbol => {
        const cachedData = currentDataCache[symbol];
        if (!cachedData || !cachedData.lastUpdated) return true;
        
        // Check if cache is older than 15 minutes
        const age = Date.now() - cachedData.lastUpdated;
        return age > CURRENT_DATA_CACHE_DURATION;
      });
      
      if (symbolsToFetch.length > 0) {
        console.log(`Fetching fresh data for ${symbolsToFetch.length} indexes that need updates...`);
        
        // Fetch data for stale indexes in parallel
        const fetchPromises = symbolsToFetch.map(async symbol => {
          try {
            const data = await fetchStockData(symbol);
            if (data) {
              currentDataCache[symbol] = data;
              const indexName = INDEX_NAMES[symbol] || symbol;
              updateIndexCard(symbol, indexName, data);
            }
          } catch (error) {
            console.error(`Error fetching index data for ${symbol}:`, error);
          }
        });
        
        await Promise.all(fetchPromises);
        
        // Save updated data to storage
        saveCurrentDataToStorage(currentDataCache);
      } else {
        console.log('All indexes have fresh cached data, no API calls needed');
      }
      
      updateCacheStatus();
    }
    
    // Render index card (for card view)
    function renderIndexCard(symbol, indexName, data) {
      // Determine card border color based on price direction
      let cardClass = 'card stock-card index-card';
      if (data && data.priceDir) {
        if (data.priceDir === 'up') {
          cardClass += ' border-success';
        } else if (data.priceDir === 'down') {
          cardClass += ' border-danger';
        }
      }
      
      const cardHtml = `
        <div class="col-md-6 col-lg-4 mb-3" data-symbol="${symbol}">
          <div class="${cardClass}">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-center mb-2">
                <h6 class="card-title mb-0">${indexName}</h6>
                <small class="text-muted">${symbol}</small>
              </div>
              <div class="row">
                <div class="col-7">
                  <div class="price-display">
                    <div class="price mb-1" id="${symbol}-price">${data ? data.price?.toFixed(2) || '-' : 'Loading...'}</div>
                    <div class="d-flex align-items-center">
                      <small class="price-change me-1 ${data ? data.priceDir || '' : ''}" id="${symbol}-pricePct">${data && data.pricePct !== null ? '(' + (data.pricePct > 0 ? '+' : '') + data.pricePct.toFixed(2) + '%)' : ''}</small>
                      <span class="direction ${data ? data.priceDir || '' : ''}" id="${symbol}-priceDir">${data ? (data.priceDir === 'up' ? '▲' : data.priceDir === 'down' ? '▼' : '') : ''}</span>
                    </div>
                  </div>
                </div>
                <div class="col-5">
                  <div class="sparkline text-end" id="${symbol}-spark">
                    ${data && data.sparkData ? renderSparkline(data.sparkData) : ''}
                  </div>
                </div>
              </div>
              <div class="mt-2 pt-2 border-top">
                <div class="row">
                  <div class="col-6">
                    <small class="text-muted d-block">Volume</small>
                    <small class="fw-medium" id="${symbol}-volume">${data ? humanVolume(data.volume) : '-'}</small>
                  </div>
                  <div class="col-6 text-end">
                    <small class="text-muted d-block">Updated</small>
                    <small class="fw-medium" id="${symbol}-updated">${data ? getTimeAgo(data.lastUpdated) : '-'}</small>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>`;
      
      const gridContainer = document.getElementById('indexGrid') || stockList;
      gridContainer.insertAdjacentHTML('beforeend', cardHtml);
    }
    
    // Update index card with data
    function updateIndexCard(symbol, indexName, data) {
      const cardElement = document.querySelector(`[data-symbol="${symbol}"] .card`);
      const priceEl = document.getElementById(`${symbol}-price`);
      const pricePctEl = document.getElementById(`${symbol}-pricePct`);
      const priceDirEl = document.getElementById(`${symbol}-priceDir`);
      const sparkEl = document.getElementById(`${symbol}-spark`);
      const volumeEl = document.getElementById(`${symbol}-volume`);
      const updatedEl = document.getElementById(`${symbol}-updated`);
      
      // Update card border color based on price direction
      if (cardElement) {
        cardElement.classList.remove('border-success', 'border-danger');
        if (data.priceDir === 'up') {
          cardElement.classList.add('border-success');
        } else if (data.priceDir === 'down') {
          cardElement.classList.add('border-danger');
        }
      }
      
      if (priceEl) priceEl.textContent = data.price?.toFixed(2) || '-';
      if (pricePctEl) {
        pricePctEl.textContent = data.pricePct !== null ? '(' + (data.pricePct > 0 ? '+' : '') + data.pricePct.toFixed(2) + '%)' : '';
        pricePctEl.className = 'price-change me-1 ' + (data.priceDir || '');
      }
      if (priceDirEl) {
        priceDirEl.textContent = data.priceDir === 'up' ? '▲' : data.priceDir === 'down' ? '▼' : '';
        priceDirEl.className = 'direction ' + (data.priceDir || '');
      }
      if (sparkEl && data.sparkData) {
        sparkEl.innerHTML = renderSparkline(data.sparkData);
      }
      if (volumeEl) volumeEl.textContent = humanVolume(data.volume);
      if (updatedEl) updatedEl.textContent = getTimeAgo(data.lastUpdated);
    }
    
    // Refresh single index
    async function refreshSingleIndex(symbol) {
      try {
        const data = await fetchStockData(symbol);
        if (data) {
          currentDataCache[symbol] = data;
          saveCurrentDataToStorage(currentDataCache);
          
          const indexName = INDEX_NAMES[symbol] || symbol;
          updateIndexCard(symbol, indexName, data);
          
          updateCacheStatus();
        }
      } catch (error) {
        console.error(`Error refreshing index ${symbol}:`, error);
      }
    }
    
    // Update notes icon appearance based on whether notes exist
    function updateNotesIcon(symbol) {
      const notesIconCard = document.getElementById(`${symbol}-notesIcon`);
      const notesIconTable = document.getElementById(`${symbol}-notesIcon-table`);
      
      const hasNotesForSymbol = hasNotes(symbol);
      const iconClass = hasNotesForSymbol ? 'bi-sticky-fill' : 'bi-sticky';
      
      // Get tags for enhanced tooltip
      const notes = getNotes(symbol);
      const tags = extractTagsFromText(notes);
      const tagText = tags.length > 0 ? ` (${tags.map(t => '#' + t).join(', ')})` : '';
      const titleText = hasNotesForSymbol ? `Edit notes${tagText}` : 'Add notes';
      
      if (notesIconCard) {
        notesIconCard.className = `notes-icon ${iconClass} ${hasNotesForSymbol ? 'has-notes' : ''}`;
        notesIconCard.title = titleText;
      }
      
      if (notesIconTable) {
        notesIconTable.className = `notes-icon ${iconClass} ${hasNotesForSymbol ? 'has-notes' : ''}`;
        notesIconTable.title = titleText;
      }
    }
    
    // Update all notes icons for all tracked stocks
    function updateAllNotesIcons() {
      const stocks = getTrackedStocks();
      stocks.forEach(stock => {
        const symbol = typeof stock === 'object' ? stock.symbol : stock;
        updateNotesIcon(symbol);
      });
    }
    
    // Render news section
    async function renderNews() {
      stockList.innerHTML = '';
      loading.style.display = 'block';
      
      try {
        // Create news container
        stockList.innerHTML = `
          <div class="row">
            <div class="col-12">
              <div class="d-flex justify-content-between align-items-center mb-3">
                <h4><i class="bi bi-newspaper me-2"></i>Latest Market News</h4>
                <div class="d-flex gap-2">
                  <select class="form-select form-select-sm" id="newsFilter" onchange="filterNews()" style="width: auto;">
                    <option value="all">All News</option>
                    <option value="stock">Stock News</option>
                    <option value="index">Index News</option>
                    <option value="market">Market News</option>
                    <option value="relevant">Your Watchlist</option>
                  </select>
                  <button class="btn btn-outline-primary btn-sm" onclick="refreshNews()" title="Refresh news">
                    <i class="bi bi-arrow-clockwise"></i> Refresh
                  </button>
                </div>
              </div>
              <div id="newsContainer">
                <div class="text-center text-muted">
                  <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                  Loading latest news...
                </div>
              </div>
            </div>
          </div>`;
        
        loading.style.display = 'none';
        
        // Load cached news first if available
        const cachedNews = loadNewsFromCache();
        if (cachedNews && cachedNews.length > 0) {
          console.log(`Showing ${cachedNews.length} cached news items while fetching fresh content...`);
          renderNewsItems(cachedNews);
        }
        
        // Fetch fresh news
        await fetchAndRenderNews();
        
      } catch (error) {
        console.error('Error rendering news:', error);
        stockList.innerHTML = `
          <div class="alert alert-danger">
            <i class="bi bi-exclamation-triangle me-2"></i>
            Error loading news. Please try again later.
            <div class="mt-2">
              <small class="text-muted">Technical details: ${error.message}</small>
            </div>
            <button class="btn btn-outline-primary btn-sm mt-2" onclick="renderNews()">
              <i class="bi bi-arrow-clockwise"></i> Try Again
            </button>
          </div>`;
      }
      
      loading.style.display = 'none';
    }
    
    // Fetch news from multiple sources with fallbacks
    async function fetchNews() {
      // Multiple RSS sources to try in order
      const NEWS_SOURCES = [
        {
          name: 'Yahoo Finance',
          url: 'https://feeds.finance.yahoo.com/rss/2.0/headline',
          proxy: 'allorigins'
        },
        {
          name: 'MarketWatch',
          url: 'https://feeds.marketwatch.com/marketwatch/realtimeheadlines/',
          proxy: 'allorigins'
        },
        {
          name: 'CNN Business', 
          url: 'https://rss.cnn.com/rss/money_latest.rss', // Changed to HTTPS
          proxy: 'allorigins'
        },
        {
          name: 'BBC Business',
          url: 'https://feeds.bbci.co.uk/news/business/rss.xml',
          proxy: 'allorigins'
        }
      ];
      
      const errors = [];
      
      for (const source of NEWS_SOURCES) {
        try {
          console.log(`Trying to fetch news from ${source.name}...`);
          
          let proxyUrl;
          if (source.proxy === 'allorigins') {
            proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(source.url)}`;
          }
          
          console.log(`Fetching from proxy URL: ${proxyUrl}`);
          
          // Create AbortController for timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 second timeout
          
          const response = await fetch(proxyUrl, {
            method: 'GET',
            headers: {
              'Accept': 'application/json',
            },
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log(`Received data from ${source.name}:`, data);
          
          if (!data.contents) {
            throw new Error('No RSS content received from proxy');
          }
          
          // Parse RSS XML
          const parser = new DOMParser();
          const xml = parser.parseFromString(data.contents, 'text/xml');
          
          // Check for parsing errors
          const parserError = xml.querySelector('parsererror');
          if (parserError) {
            console.error('RSS parsing error:', parserError.textContent);
            throw new Error('Failed to parse RSS XML');
          }
          
          const items = xml.querySelectorAll('item');
          console.log(`Found ${items.length} items from ${source.name}`);
          
          if (items.length === 0) {
            throw new Error('No news items found in RSS feed');
          }
          
          const newsItems = Array.from(items).slice(0, 20).map(item => {
            const title = item.querySelector('title')?.textContent || 'No title';
            const link = item.querySelector('link')?.textContent || '#';
            const description = item.querySelector('description')?.textContent || '';
            const pubDate = item.querySelector('pubDate')?.textContent || '';
            
            // Clean up description (remove HTML tags and decode entities)
            const cleanDescription = description
              .replace(/<[^>]*>/g, '')
              .replace(/&amp;/g, '&')
              .replace(/&lt;/g, '<')
              .replace(/&gt;/g, '>')
              .replace(/&quot;/g, '"')
              .replace(/&#39;/g, "'")
              .trim();
            
            // Categorize news and find related assets
            const newsAnalysis = categorizeNews(title, cleanDescription);
            
            return {
              title: title.trim(),
              link: link.trim(),
              description: cleanDescription,
              pubDate: pubDate ? new Date(pubDate) : new Date(),
              timestamp: Date.now(),
              source: source.name,
              category: newsAnalysis.category,
              relatedAssets: newsAnalysis.relatedAssets,
              relevanceScore: newsAnalysis.relevanceScore
            };
          });
          
          console.log(`Successfully fetched ${newsItems.length} news items from ${source.name}`);
          return newsItems;
          
        } catch (error) {
          const errorMsg = `${source.name}: ${error.message}`;
          console.warn(errorMsg);
          errors.push(errorMsg);
          // Continue to next source
        }
      }
      
      // If all sources failed, throw error with details
      const errorDetails = errors.join('; ');
      throw new Error(`All news sources failed: ${errorDetails}`);
    }
    
    // Categorize news and find related assets
    function categorizeNews(title, description) {
      const text = (title + ' ' + description).toLowerCase();
      const userStocks = getTrackedStocks();
      const relatedAssets = [];
      let category = 'general';
      let relevanceScore = 0;
      
      // Check for user's tracked stocks
      userStocks.forEach(stock => {
        const symbol = typeof stock === 'object' ? stock.symbol : stock;
        const symbolLower = symbol.toLowerCase();
        const companyPatterns = getCompanyPatterns(symbol);
        
        if (text.includes(symbolLower) || companyPatterns.some(pattern => text.includes(pattern))) {
          relatedAssets.push({ symbol, type: 'stock', inWatchlist: true });
          category = 'stock';
          relevanceScore += 10; // High relevance for user's stocks
        }
      });
      
      // Check for major indexes
      MAJOR_INDEXES.forEach(symbol => {
        const indexName = INDEX_NAMES[symbol] || symbol;
        const symbolLower = symbol.toLowerCase().replace('^', '').replace('=f', '');
        const indexNameLower = indexName.toLowerCase();
        
        if (text.includes(symbolLower) || text.includes(indexNameLower) || 
            text.includes(indexName.toLowerCase().replace(/\s+/g, ''))) {
          relatedAssets.push({ symbol, type: 'index', name: indexName });
          if (category === 'general') category = 'index';
          relevanceScore += 5; // Medium relevance for indexes
        }
      });
      
      // Check for popular stocks (even if not in user's watchlist)
      const popularStocks = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX', 'AMD', 'BABA'];
      popularStocks.forEach(symbol => {
        if (!userStocks.includes(symbol)) {
          const symbolLower = symbol.toLowerCase();
          const companyPatterns = getCompanyPatterns(symbol);
          
          if (text.includes(symbolLower) || companyPatterns.some(pattern => text.includes(pattern))) {
            relatedAssets.push({ symbol, type: 'stock', inWatchlist: false });
            if (category === 'general') category = 'stock';
            relevanceScore += 3; // Lower relevance for non-watchlist stocks
          }
        }
      });
      
      // Check for sector/market keywords
      const sectorKeywords = {
        'Technology': ['tech', 'technology', 'software', 'ai', 'artificial intelligence', 'cloud', 'semiconductor'],
        'Healthcare': ['healthcare', 'pharma', 'biotech', 'medical', 'drug', 'vaccine'],
        'Financial': ['bank', 'financial', 'credit', 'loan', 'insurance', 'fintech'],
        'Energy': ['oil', 'energy', 'gas', 'renewable', 'solar', 'electric vehicle'],
        'Consumer': ['retail', 'consumer', 'shopping', 'e-commerce'],
        'Crypto': ['bitcoin', 'crypto', 'cryptocurrency', 'blockchain', 'ethereum']
      };
      
      Object.entries(sectorKeywords).forEach(([sector, keywords]) => {
        if (keywords.some(keyword => text.includes(keyword))) {
          if (!relatedAssets.some(asset => asset.sector === sector)) {
            relatedAssets.push({ type: 'sector', sector, name: sector });
            relevanceScore += 2;
          }
        }
      });
      
      // Market-wide keywords
      const marketKeywords = ['market', 'dow', 'nasdaq', 's&p', 'federal reserve', 'fed', 'inflation', 'gdp', 'earnings', 'economy'];
      if (marketKeywords.some(keyword => text.includes(keyword))) {
        if (category === 'general') category = 'market';
        relevanceScore += 1;
      }
      
      return {
        category,
        relatedAssets: relatedAssets.slice(0, 5), // Limit to 5 related assets
        relevanceScore
      };
    }
    
    // Get company name patterns for better matching
    function getCompanyPatterns(symbol) {
      const companyNames = {
        'AAPL': ['apple', 'iphone', 'ipad', 'mac', 'ios'],
        'MSFT': ['microsoft', 'windows', 'azure', 'xbox', 'office'],
        'GOOGL': ['google', 'alphabet', 'youtube', 'android', 'search'],
        'AMZN': ['amazon', 'aws', 'prime', 'alexa'],
        'TSLA': ['tesla', 'elon musk', 'electric vehicle', 'ev', 'spacex'],
        'META': ['meta', 'facebook', 'instagram', 'whatsapp', 'metaverse'],
        'NVDA': ['nvidia', 'gpu', 'graphics', 'ai chip'],
        'NFLX': ['netflix', 'streaming'],
        'AMD': ['amd', 'ryzen', 'radeon'],
        'BABA': ['alibaba', 'aliexpress']
      };
      
      return companyNames[symbol] || [];
    }
    
    // Cache management for news
    const NEWS_CACHE_KEY = 'stockNews';
    const NEWS_CACHE_DURATION = 15 * 60 * 1000; // 15 minutes
    
    function saveNewsToCache(newsItems) {
      const cacheData = {
        items: newsItems,
        timestamp: Date.now()
      };
      localStorage.setItem(NEWS_CACHE_KEY, JSON.stringify(cacheData));
    }
    
    function loadNewsFromCache() {
      try {
        const cached = localStorage.getItem(NEWS_CACHE_KEY);
        if (!cached) return null;
        
        const cacheData = JSON.parse(cached);
        const age = Date.now() - cacheData.timestamp;
        
        if (age > NEWS_CACHE_DURATION) {
          localStorage.removeItem(NEWS_CACHE_KEY);
          return null;
        }
        
        return cacheData.items;
      } catch (error) {
        console.error('Error loading news from cache:', error);
        return null;
      }
    }
    
    // Fetch and render news
    async function fetchAndRenderNews() {
      try {
        const newsItems = await fetchNews();
        saveNewsToCache(newsItems);
        renderNewsItems(newsItems);
      } catch (error) {
        console.error('Error fetching news:', error);
        
        const newsContainer = document.getElementById('newsContainer');
        if (newsContainer) {
          // Check if we have cached news first
          const cachedNews = loadNewsFromCache();
          if (cachedNews && cachedNews.length > 0) {
            // Show cached content with error notice
            renderNewsItems(cachedNews);
            const errorNotice = document.createElement('div');
            errorNotice.className = 'alert alert-warning alert-dismissible fade show mb-3';
            errorNotice.innerHTML = `
              <i class="bi bi-exclamation-triangle me-2"></i>
              Could not load fresh news. Showing cached content. 
              <small class="d-block mt-1">Error: ${error.message}</small>
              <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            newsContainer.insertBefore(errorNotice, newsContainer.firstChild);
          } else {
            // No cached content available, show error message only (no sample news)
            newsContainer.innerHTML = `
              <div class="alert alert-warning">
                <i class="bi bi-exclamation-triangle me-2"></i>
                Unable to load fresh news. Please check your internet connection and try again.
                <small class="d-block mt-1">Error: ${error.message}</small>
                <button class="btn btn-outline-primary btn-sm ms-2 mt-2" onclick="fetchAndRenderNews()">
                  <i class="bi bi-arrow-clockwise"></i> Try Again
                </button>
              </div>`;
          }
        }
      }
    }
    
    // Fallback news items when feeds are unavailable
    function getFallbackNews() {
      const now = new Date();
      return [
        {
          title: "Market Opens with Mixed Signals as Investors Await Economic Data",
          description: "Stock futures showed mixed results in early trading as investors prepared for key economic indicators and earnings reports.",
          link: "https://finance.yahoo.com",
          pubDate: new Date(now.getTime() - 30 * 60000), // 30 minutes ago
          source: "Sample News",
          timestamp: Date.now()
        },
        {
          title: "Tech Stocks Continue to Show Resilience Amid Market Volatility",
          description: "Major technology companies maintained their gains as the sector demonstrated strong fundamentals despite broader market concerns.",
          link: "https://finance.yahoo.com",
          pubDate: new Date(now.getTime() - 2 * 60 * 60000), // 2 hours ago
          source: "Sample News",
          timestamp: Date.now()
        },
        {
          title: "Federal Reserve Officials Signal Measured Approach to Policy Changes",
          description: "Central bank officials indicated a cautious stance on monetary policy adjustments in recent public statements.",
          link: "https://finance.yahoo.com",
          pubDate: new Date(now.getTime() - 4 * 60 * 60000), // 4 hours ago
          source: "Sample News",
          timestamp: Date.now()
        },
        {
          title: "Energy Sector Gains Momentum on Supply Chain Developments",
          description: "Oil and gas companies saw increased investor interest following positive developments in global supply chain conditions.",
          link: "https://finance.yahoo.com",
          pubDate: new Date(now.getTime() - 6 * 60 * 60000), // 6 hours ago
          source: "Sample News",
          timestamp: Date.now()
        },
        {
          title: "International Markets Show Steady Performance Ahead of Key Announcements",
          description: "Global equity markets demonstrated stability as traders positioned for upcoming economic announcements from major economies.",
          link: "https://finance.yahoo.com",
          pubDate: new Date(now.getTime() - 8 * 60 * 60000), // 8 hours ago
          source: "Sample News",
          timestamp: Date.now()
        }
      ];
    }
    
    // Render news items
    function renderNewsItems(newsItems) {
      const newsContainer = document.getElementById('newsContainer');
      if (!newsContainer || !newsItems || newsItems.length === 0) {
        if (newsContainer) {
          newsContainer.innerHTML = `
            <div class="alert alert-info">
              <i class="bi bi-info-circle me-2"></i>
              No news items available at the moment.
            </div>`;
        }
        return;
      }
      
      // Store all news items for filtering
      allNewsItems = newsItems.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));
      
      const newsHtml = newsItems.map((item, index) => {
        // Ensure pubDate is a proper Date object
        let pubDate;
        if (item.pubDate instanceof Date) {
          pubDate = item.pubDate;
        } else if (typeof item.pubDate === 'string' || typeof item.pubDate === 'number') {
          pubDate = new Date(item.pubDate);
        } else {
          pubDate = new Date(); // fallback to current date
        }
        
        // Validate the date
        if (isNaN(pubDate.getTime())) {
          pubDate = new Date(); // fallback if invalid
        }
        
        const timeAgo = getNewsTimeAgo(pubDate);
        const shortDescription = item.description && item.description.length > 150 
          ? item.description.substring(0, 150) + '...' 
          : (item.description || '');
        
        // Determine if this is fallback/sample news
        const isSampleNews = item.source === 'Sample News';
        const sourceDisplay = item.source || 'Unknown Source';
        
        // Format date and time safely
        const dateStr = pubDate.toLocaleDateString();
        const timeStr = pubDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        // Get category styling and icon
        const categoryInfo = getCategoryInfo(item.category || 'general');
        
        // Generate related assets badges
        const relatedAssetsBadges = generateRelatedAssetsBadges(item.relatedAssets || []);
        
        // Determine if this news is highly relevant to user
        const isHighRelevance = (item.relevanceScore || 0) >= 10;
        
        return `
          <div class="card mb-3 news-item ${isSampleNews ? 'border-info' : ''} ${isHighRelevance ? 'border-warning' : ''}" data-index="${index}">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-start mb-2">
                <div class="d-flex align-items-center">
                  <span class="badge ${categoryInfo.badgeClass} me-2" title="${categoryInfo.description}">
                    <i class="${categoryInfo.icon} me-1"></i>${categoryInfo.label}
                  </span>
                  ${isHighRelevance ? '<span class="badge bg-warning text-dark me-2" title="Highly relevant to your watchlist"><i class="bi bi-star-fill"></i></span>' : ''}
                </div>
                <small class="text-muted ms-2 flex-shrink-0">${timeAgo}</small>
              </div>
              
              <h6 class="card-title mb-2">
                <a href="${item.link}" target="_blank" rel="noopener" class="text-decoration-none news-link">
                  ${item.title || 'No title'}
                </a>
              </h6>
              
              ${shortDescription ? `<p class="card-text text-muted small mb-2">${shortDescription}</p>` : ''}
              
              ${relatedAssetsBadges ? `
                <div class="mb-2">
                  <small class="text-muted">Related to:</small>
                  <div class="mt-1">${relatedAssetsBadges}</div>
                </div>
              ` : ''}
              
              <div class="d-flex justify-content-between align-items-center">
                <small class="text-muted">
                  <i class="bi bi-building me-1"></i>${sourceDisplay}
                  <span class="mx-2">•</span>
                  <i class="bi bi-calendar3 me-1"></i>
                  ${dateStr} ${timeStr}
                </small>
                <a href="${item.link || '#'}" target="_blank" rel="noopener" class="btn btn-outline-primary btn-sm">
                  <i class="bi bi-box-arrow-up-right me-1"></i>Read More
                </a>
              </div>
              ${isSampleNews ? '<div class="mt-1"><small class="text-info"><i class="bi bi-info-circle me-1"></i>Sample news - Live feeds temporarily unavailable</small></div>' : ''}
            </div>
          </div>`;
      }).join('');
      
      newsContainer.innerHTML = newsHtml;
    }
    
    // Get category information for styling
    function getCategoryInfo(category) {
      const categoryMap = {
        'stock': {
          label: 'Stock',
          icon: 'bi-graph-up',
          badgeClass: 'bg-success',
          description: 'Individual stock news'
        },
        'index': {
          label: 'Index',
          icon: 'bi-graph-up-arrow',
          badgeClass: 'bg-info',
          description: 'Market index news'
        },
        'market': {
          label: 'Market',
          icon: 'bi-bar-chart',
          badgeClass: 'bg-primary',
          description: 'General market news'
        },
        'general': {
          label: 'General',
          icon: 'bi-newspaper',
          badgeClass: 'bg-secondary',
          description: 'General financial news'
        }
      };
      
      return categoryMap[category] || categoryMap['general'];
    }
    
    // Generate badges for related assets
    function generateRelatedAssetsBadges(relatedAssets) {
      if (!relatedAssets || relatedAssets.length === 0) return '';
      
      return relatedAssets.map(asset => {
        let badgeClass = 'bg-light text-dark';
        let icon = 'bi-tag';
        let text = '';
        let clickable = false;
        
        if (asset.type === 'stock') {
          badgeClass = asset.inWatchlist ? 'bg-success' : 'bg-outline-success text-success';
          icon = 'bi-graph-up';
          text = asset.symbol;
          clickable = true;
        } else if (asset.type === 'index') {
          badgeClass = 'bg-info';
          icon = 'bi-graph-up-arrow';
          text = asset.name || asset.symbol;
          clickable = true;
        } else if (asset.type === 'sector') {
          badgeClass = 'bg-warning text-dark';
          icon = 'bi-collection';
          text = asset.sector;
        }
        
        const title = asset.inWatchlist === false ? 
          `${asset.symbol} (not in your watchlist)` : 
          (asset.name || asset.symbol || asset.sector);
          
        if (clickable && asset.symbol) {
          return `<span class="badge ${badgeClass} me-1 cursor-pointer" 
                        title="${title}" 
                        onclick="highlightAsset('${asset.symbol}', '${asset.type}')">
                    <i class="${icon} me-1"></i>${text}
                  </span>`;
        } else {
          return `<span class="badge ${badgeClass} me-1" title="${title}">
                    <i class="${icon} me-1"></i>${text}
                  </span>`;
        }
      }).join('');
    }
    
    // Highlight related asset in the UI
    function highlightAsset(symbol, type) {
      if (type === 'stock') {
        // Check if user has this stock in watchlist
        const userStocks = getTrackedStocks();
        if (userStocks.includes(symbol)) {
          // Switch to the appropriate watchlist and highlight the stock
          if (currentViewMode !== 'watchlist') {
            switchWatchlist(getCurrentWatchlistName());
          }
          // Scroll to and highlight the stock card/row
          setTimeout(() => {
            const stockElement = document.querySelector(`[data-symbol="${symbol}"]`);
            if (stockElement) {
              stockElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
              stockElement.classList.add('highlight-flash');
              setTimeout(() => stockElement.classList.remove('highlight-flash'), 2000);
            }
          }, 500);
        } else {
          // Show option to add stock to watchlist
          if (confirm(`Add ${symbol} to your current watchlist?`)) {
            let stocks = getTrackedStocks();
            if (!stocks.includes(symbol)) {
              stocks.push(symbol);
              setTrackedStocks(stocks);
              renderWatchlistTabs();
              // Switch to watchlist view and fetch data
              switchWatchlist(getCurrentWatchlistName());
            }
          }
        }
      } else if (type === 'index') {
        // Switch to indexes view and highlight the index
        if (currentViewMode !== 'indexes') {
          switchToIndexes();
        }
        setTimeout(() => {
          const indexElement = document.querySelector(`[data-symbol="${symbol}"]`);
          if (indexElement) {
            indexElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            indexElement.classList.add('highlight-flash');
            setTimeout(() => indexElement.classList.remove('highlight-flash'), 2000);
          }
        }, 500);
      }
    }
    
    // Store all news items for filtering
    let allNewsItems = [];
    
    // Filter news by category
    function filterNews() {
      const filter = document.getElementById('newsFilter')?.value || 'all';
      const newsContainer = document.getElementById('newsContainer');
      
      if (!allNewsItems || allNewsItems.length === 0) {
        return; // No news to filter
      }
      
      let filteredNews = [...allNewsItems];
      
      switch (filter) {
        case 'stock':
          filteredNews = allNewsItems.filter(item => item.category === 'stock');
          break;
        case 'index':
          filteredNews = allNewsItems.filter(item => item.category === 'index');
          break;
        case 'market':
          filteredNews = allNewsItems.filter(item => item.category === 'market');
          break;
        case 'relevant':
          filteredNews = allNewsItems.filter(item => (item.relevanceScore || 0) >= 10);
          break;
        case 'all':
        default:
          // Show all news, but sort by relevance
          filteredNews = allNewsItems.sort((a, b) => (b.relevanceScore || 0) - (a.relevanceScore || 0));
          break;
      }
      
      if (filteredNews.length === 0) {
        newsContainer.innerHTML = `
          <div class="alert alert-info">
            <i class="bi bi-info-circle me-2"></i>
            No news items found for the selected filter.
          </div>`;
        return;
      }
      
      renderFilteredNewsItems(filteredNews);
    }
    
    // Render filtered news items (similar to renderNewsItems but uses filteredNews)
    function renderFilteredNewsItems(newsItems) {
      const newsContainer = document.getElementById('newsContainer');
      if (!newsContainer || !newsItems || newsItems.length === 0) {
        return;
      }
      
      // Use the same rendering logic as renderNewsItems
      const newsHtml = newsItems.map((item, index) => {
        // ... (same rendering logic as in renderNewsItems)
        let pubDate;
        if (item.pubDate instanceof Date) {
          pubDate = item.pubDate;
        } else if (typeof item.pubDate === 'string' || typeof item.pubDate === 'number') {
          pubDate = new Date(item.pubDate);
        } else {
          pubDate = new Date();
        }
        
        if (isNaN(pubDate.getTime())) {
          pubDate = new Date();
        }
        
        const timeAgo = getNewsTimeAgo(pubDate);
        const shortDescription = item.description && item.description.length > 150 
          ? item.description.substring(0, 150) + '...' 
          : (item.description || '');
        
        const isSampleNews = item.source === 'Sample News';
        const sourceDisplay = item.source || 'Unknown Source';
        const dateStr = pubDate.toLocaleDateString();
        const timeStr = pubDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const categoryInfo = getCategoryInfo(item.category || 'general');
        const relatedAssetsBadges = generateRelatedAssetsBadges(item.relatedAssets || []);
        const isHighRelevance = (item.relevanceScore || 0) >= 10;
        
        return `
          <div class="card mb-3 news-item ${isSampleNews ? 'border-info' : ''} ${isHighRelevance ? 'border-warning' : ''}" data-index="${index}">
            <div class="card-body">
              <div class="d-flex justify-content-between align-items-start mb-2">
                <div class="d-flex align-items-center">
                  <span class="badge ${categoryInfo.badgeClass} me-2" title="${categoryInfo.description}">
                    <i class="${categoryInfo.icon} me-1"></i>${categoryInfo.label}
                  </span>
                  ${isHighRelevance ? '<span class="badge bg-warning text-dark me-2" title="Highly relevant to your watchlist"><i class="bi bi-star-fill"></i></span>' : ''}
                </div>
                <small class="text-muted ms-2 flex-shrink-0">${timeAgo}</small>
              </div>
              
              <h6 class="card-title mb-2">
                <a href="${item.link}" target="_blank" rel="noopener" class="text-decoration-none news-link">
                  ${item.title || 'No title'}
                </a>
              </h6>
              
              ${shortDescription ? `<p class="card-text text-muted small mb-2">${shortDescription}</p>` : ''}
              
              ${relatedAssetsBadges ? `
                <div class="mb-2">
                  <small class="text-muted">Related to:</small>
                  <div class="mt-1">${relatedAssetsBadges}</div>
                </div>
              ` : ''}
              
              <div class="d-flex justify-content-between align-items-center">
                <small class="text-muted">
                  <i class="bi bi-building me-1"></i>${sourceDisplay}
                  <span class="mx-2">•</span>
                  <i class="bi bi-calendar3 me-1"></i>
                  ${dateStr} ${timeStr}
                </small>
                <a href="${item.link || '#'}" target="_blank" rel="noopener" class="btn btn-outline-primary btn-sm">
                  <i class="bi bi-box-arrow-up-right me-1"></i>Read More
                </a>
              </div>
              ${isSampleNews ? '<div class="mt-1"><small class="text-info"><i class="bi bi-info-circle me-1"></i>Sample news - Live feeds temporarily unavailable</small></div>' : ''}
            </div>
          </div>`;
      }).join('');
      
      newsContainer.innerHTML = newsHtml;
    }
    
    // Get time ago for any timestamp (stocks, indexes, etc.)
    function getTimeAgo(timestamp) {
      if (!timestamp) return 'Never';
      
      const now = new Date();
      const date = new Date(timestamp);
      
      if (isNaN(date.getTime())) return 'Unknown';
      
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays === 1) return 'Yesterday';
      if (diffDays < 7) return `${diffDays}d ago`;
      return date.toLocaleDateString();
    }
    
    // Get time ago for news items
    function getNewsTimeAgo(date) {
      // Ensure we have a valid Date object
      let validDate;
      if (date instanceof Date && !isNaN(date.getTime())) {
        validDate = date;
      } else if (typeof date === 'string' || typeof date === 'number') {
        validDate = new Date(date);
        if (isNaN(validDate.getTime())) {
          return 'Unknown time';
        }
      } else {
        return 'Unknown time';
      }
      
      const now = new Date();
      const diffMs = now - validDate;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffMins < 1) return 'Just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffHours < 24) return `${diffHours}h ago`;
      if (diffDays === 1) return 'Yesterday';
      if (diffDays < 7) return `${diffDays}d ago`;
      return validDate.toLocaleDateString();
    }
    
    // Refresh news function
    async function refreshNews() {
      const refreshBtn = document.querySelector('[onclick="refreshNews()"]');
      if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Refreshing...';
      }
      
      try {
        await fetchAndRenderNews();
      } finally {
        if (refreshBtn) {
          refreshBtn.disabled = false;
          refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh';
        }
      }
    }
    
    function showAddWatchlistModal() {
      renderWatchlistManagementModal();
      const modal = new bootstrap.Modal(document.getElementById('watchlistModal'));
      modal.show();
    }
    
    function renderWatchlistManagementModal() {
      const managementList = document.getElementById('watchlistManagementList');
      if (!managementList) return;
      
      const watchlists = getWatchlists();
      const currentName = getCurrentWatchlistName();
      
      let html = '';
      watchlists.forEach(watchlist => {
        const isActive = watchlist.name === currentName;
        const stockCount = watchlist.stocks.length;
        const canDelete = watchlists.length > 1; // Don't allow deleting the last watchlist
        
        html += `
          <div class="card mb-2">
            <div class="card-body py-2">
              <div class="d-flex justify-content-between align-items-center">
                <div>
                  <strong>${watchlist.name}</strong>
                  ${isActive ? '<span class="badge bg-primary ms-2">Active</span>' : ''}
                  <small class="text-muted ms-2">${stockCount} stocks</small>
                </div>
                <div class="btn-group btn-group-sm" role="group">
                  ${!isActive ? `<button class="btn btn-outline-primary" onclick="switchToWatchlist('${watchlist.name}')">Switch</button>` : ''}
                  <button class="btn btn-outline-secondary" onclick="renameWatchlist('${watchlist.name}')">Rename</button>
                  ${canDelete ? `<button class="btn btn-outline-danger" onclick="deleteWatchlist('${watchlist.name}')">Delete</button>` : ''}
                </div>
              </div>
            </div>
          </div>`;
      });
      
      managementList.innerHTML = html || '<p class="text-muted">No watchlists found.</p>';
    }
    
    function createNewWatchlist() {
      const nameInput = document.getElementById('newWatchlistName');
      const name = nameInput.value.trim();
      
      if (!name) {
        alert('Please enter a watchlist name');
        return;
      }
      
      const watchlists = getWatchlists();
      if (watchlists.find(w => w.name === name)) {
        alert('A watchlist with that name already exists!');
        return;
      }
      
      // Add new watchlist
      watchlists.push({ name: name, stocks: [] });
      setWatchlists(watchlists);
      
      // Switch to new watchlist
      setCurrentWatchlistName(name);
      renderWatchlistTabs();
      renderStocks();
      
      // Clear input and refresh modal
      nameInput.value = '';
      renderWatchlistManagementModal();
    }
    
    function createPredefinedWatchlist(name) {
      const watchlists = getWatchlists();
      if (watchlists.find(w => w.name === name)) {
        alert('A watchlist with that name already exists!');
        return;
      }
      
      // Add new watchlist
      watchlists.push({ name: name, stocks: [] });
      setWatchlists(watchlists);
      
      // Switch to new watchlist
      setCurrentWatchlistName(name);
      renderWatchlistTabs();
      renderStocks();
      
      // Refresh modal
      renderWatchlistManagementModal();
    }
    
    function switchToWatchlist(name) {
      setCurrentWatchlistName(name);
      renderWatchlistTabs();
      renderStocks();
      
      // Close modal
      const modal = bootstrap.Modal.getInstance(document.getElementById('watchlistModal'));
      if (modal) modal.hide();
    }
    
    function renameWatchlist(oldName) {
      const newName = prompt('Enter new name for watchlist:', oldName);
      if (!newName || newName.trim() === '' || newName === oldName) return;
      
      const trimmedName = newName.trim();
      const watchlists = getWatchlists();
      
      // Check if new name already exists
      if (watchlists.find(w => w.name === trimmedName)) {
        alert('A watchlist with that name already exists!');
        return;
      }
      
      // Rename watchlist
      const watchlistIndex = watchlists.findIndex(w => w.name === oldName);
      if (watchlistIndex >= 0) {
        watchlists[watchlistIndex].name = trimmedName;
        setWatchlists(watchlists);
        
        // Update current watchlist name if it was the active one
        if (getCurrentWatchlistName() === oldName) {
          setCurrentWatchlistName(trimmedName);
        }
        
        renderWatchlistTabs();
        renderWatchlistManagementModal();
      }
    }
    
    function deleteWatchlist(name) {
      const watchlists = getWatchlists();
      if (watchlists.length <= 1) {
        alert('Cannot delete the last watchlist!');
        return;
      }
      
      if (!confirm(`Are you sure you want to delete the "${name}" watchlist and all its stocks?`)) {
        return;
      }
      
      // Remove watchlist
      const newWatchlists = watchlists.filter(w => w.name !== name);
      setWatchlists(newWatchlists);
      
      // If deleted watchlist was active, switch to first available
      if (getCurrentWatchlistName() === name) {
        setCurrentWatchlistName(newWatchlists[0].name);
        renderStocks();
      }
      
      renderWatchlistTabs();
      renderWatchlistManagementModal();
    }
    
    function showWatchlistContextMenu(event, watchlistName) {
      event.preventDefault();
      
      // Create context menu dynamically
      const existingMenu = document.getElementById('watchlistContextMenu');
      if (existingMenu) existingMenu.remove();
      
      const watchlists = getWatchlists();
      const canDelete = watchlists.length > 1;
      
      const menu = document.createElement('div');
      menu.id = 'watchlistContextMenu';
      menu.className = 'dropdown-menu show';
      menu.style.position = 'fixed';
      menu.style.left = event.clientX + 'px';
      menu.style.top = event.clientY + 'px';
      menu.style.zIndex = '1050';
      
      menu.innerHTML = `
        <li><a class="dropdown-item" href="#" onclick="renameWatchlist('${watchlistName}'); hideContextMenu(); return false;">
          <i class="bi bi-pencil me-1"></i>Rename
        </a></li>
        ${canDelete ? `
        <li><a class="dropdown-item text-danger" href="#" onclick="deleteWatchlist('${watchlistName}'); hideContextMenu(); return false;">
          <i class="bi bi-trash me-1"></i>Delete
        </a></li>` : ''}
        <li><hr class="dropdown-divider"></li>
        <li><a class="dropdown-item" href="#" onclick="showAddWatchlistModal(); hideContextMenu(); return false;">
          <i class="bi bi-gear me-1"></i>Manage All
        </a></li>
      `;
      
      document.body.appendChild(menu);
      
      // Hide menu when clicking elsewhere
      const hideMenu = (e) => {
        if (!menu.contains(e.target)) {
          hideContextMenu();
          document.removeEventListener('click', hideMenu);
        }
      };
      setTimeout(() => document.addEventListener('click', hideMenu), 0);
    }
    
    function hideContextMenu() {
      const menu = document.getElementById('watchlistContextMenu');
      if (menu) menu.remove();
    }
    
    function moveStockToWatchlist(symbol, targetWatchlistName) {
      const currentWatchlist = getCurrentWatchlistName();
      if (currentWatchlist === targetWatchlistName) return;
      
      // Remove from current watchlist
      let stocks = getTrackedStocks();
      stocks = stocks.filter(s => (typeof s === 'object' ? s.symbol : s) !== symbol);
      setTrackedStocks(stocks);
      
      // Add to target watchlist
      const watchlists = getWatchlists();
      const targetIndex = watchlists.findIndex(w => w.name === targetWatchlistName);
      if (targetIndex >= 0) {
        if (!watchlists[targetIndex].stocks.includes(symbol)) {
          watchlists[targetIndex].stocks.push(symbol);
          setWatchlists(watchlists);
        }
      }
      
      // Refresh display
      renderWatchlistTabs();
      renderStocks();
    }
    
    function showWatchlistMoveModal(symbol) {
      const watchlists = getWatchlists();
      const currentWatchlist = getCurrentWatchlistName();
      const otherWatchlists = watchlists.filter(w => w.name !== currentWatchlist);
      
      let options = otherWatchlists.map((w, index) => `${index + 1}. ${w.name}`).join('\n');
      const choice = prompt(`Move ${symbol} to which watchlist?\n\n${options}\n\nEnter the number:`);
      
      if (choice) {
        const index = parseInt(choice) - 1;
        if (index >= 0 && index < otherWatchlists.length) {
          moveStockToWatchlist(symbol, otherWatchlists[index].name);
        }
      }
    }
    
    function generateStockDropdownMenu(symbol) {
      const watchlists = getWatchlists();
      const currentWatchlist = getCurrentWatchlistName();
      const otherWatchlists = watchlists.filter(w => w.name !== currentWatchlist);
      
      let moveOptions = '';
      if (otherWatchlists.length > 0) {
        // Limit to first 3 watchlists to prevent overflow, with "more" option if needed
        const displayWatchlists = otherWatchlists.slice(0, 3);
        const hasMore = otherWatchlists.length > 3;
        
        moveOptions = `<li><hr class="dropdown-divider"></li>
        <li><h6 class="dropdown-header">Move to:</h6></li>` +
        displayWatchlists.map(w => 
          `<li><a class="dropdown-item" href="#" onclick="moveStockToWatchlist('${symbol}', '${w.name}'); event.target.closest('.dropdown-menu').parentElement.querySelector('.dropdown-toggle').click(); return false;">
            <i class="bi bi-arrow-right me-1"></i>${w.name}
          </a></li>`
        ).join('');
        
        if (hasMore) {
          moveOptions += `<li><a class="dropdown-item" href="#" onclick="showWatchlistMoveModal('${symbol}'); event.target.closest('.dropdown-menu').parentElement.querySelector('.dropdown-toggle').click(); return false;">
            <i class="bi bi-three-dots me-1"></i>More watchlists...
          </a></li>`;
        }
        
        moveOptions += `<li><hr class="dropdown-divider"></li>`;
      }
      
      return `
        <li><a class="dropdown-item" href="#" onclick="refreshSingleStock('${symbol}'); event.target.closest('.dropdown-menu').parentElement.querySelector('.dropdown-toggle').click(); return false;"><i class="bi bi-arrow-clockwise me-1"></i>Refresh</a></li>
        <li><a class="dropdown-item" href="#" onclick="showAlertsModal('${symbol}'); event.target.closest('.dropdown-menu').parentElement.querySelector('.dropdown-toggle').click(); return false;"><i class="bi bi-bell me-1"></i>Alerts</a></li>
        <li><a class="dropdown-item" href="https://finance.yahoo.com/quote/${symbol}" target="_blank" rel="noopener"><i class="bi bi-info-circle me-1"></i>Info</a></li>
        <li><a class="dropdown-item" href="https://www.tradingview.com/symbols/${symbol}/" target="_blank" rel="noopener"><i class="bi bi-graph-up me-1"></i>Chart</a></li>
        ${moveOptions}
        <li><a class="dropdown-item text-danger" href="#" onclick="removeStock('${symbol}'); event.target.closest('.dropdown-menu').parentElement.querySelector('.dropdown-toggle').click(); return false;"><i class="bi bi-trash me-1"></i>Delete</a></li>
      `;
    }

    // UI Elements
    const addStockForm = document.getElementById('addStockForm');
    const stockInput = document.getElementById('stockInput');
    const stockList = document.getElementById('stockList');
    const loading = document.getElementById('loading');
    const filterInput = document.getElementById('filterInput');
    const fetchError = document.getElementById('fetchError');
    const cacheStatus = document.getElementById('cacheStatus');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsModal = document.getElementById('settingsModal');
    const refreshIntervalInput = document.getElementById('refreshInterval');
    const darkModeSwitch = document.getElementById('darkModeSwitch');
    const tableViewSwitch = document.getElementById('tableViewSwitch');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const userEmailInput = document.getElementById('userEmail');
    
    // Smart Alert UI Elements
    const smartAlertsSwitch = document.getElementById('smartAlertsSwitch');
    const smartAlertSettings = document.getElementById('smartAlertSettings');
    const smartAlertBuyThreshold = document.getElementById('smartAlertBuyThreshold');
    const smartAlertSellThreshold = document.getElementById('smartAlertSellThreshold');
    const smartAlertEmailSwitch = document.getElementById('smartAlertEmailSwitch');
    
    // --- Stock Input Autocomplete System ---
    let autocompleteTimeout = null;
    let selectedSuggestionIndex = -1;
    let currentSuggestions = [];
    let isAutocompleteVisible = false;
    
    // Setup autocomplete functionality
    function setupStockAutocomplete() {
      const stockInput = document.getElementById('stockInput');
      const autocompleteContainer = document.getElementById('stockAutocomplete');
      
      if (!stockInput || !autocompleteContainer) return;
      
      // Auto-uppercase input
      stockInput.addEventListener('input', function(e) {
        // Convert to uppercase
        const cursorPos = e.target.selectionStart;
        const oldValue = e.target.value;
        const newValue = oldValue.toUpperCase();
        
        if (oldValue !== newValue) {
          e.target.value = newValue;
          e.target.setSelectionRange(cursorPos, cursorPos);
        }
        
        handleAutocompleteInput(e);
      });
      
      // Handle keyboard navigation
      stockInput.addEventListener('keydown', function(e) {
        if (!isAutocompleteVisible) return;
        
        switch(e.key) {
          case 'ArrowDown':
            e.preventDefault();
            selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, currentSuggestions.length - 1);
            updateSuggestionSelection();
            break;
          case 'ArrowUp':
            e.preventDefault();
            selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
            updateSuggestionSelection();
            break;
          case 'Enter':
            e.preventDefault();
            if (selectedSuggestionIndex >= 0 && currentSuggestions[selectedSuggestionIndex]) {
              selectSuggestion(currentSuggestions[selectedSuggestionIndex]);
            }
            break;
          case 'Escape':
            hideAutocomplete();
            break;
        }
      });
      
      // Hide autocomplete when clicking outside
      document.addEventListener('click', function(e) {
        if (!stockInput.contains(e.target) && !autocompleteContainer.contains(e.target)) {
          hideAutocomplete();
        }
      });
      
      // Hide autocomplete when input loses focus (with delay for click handling)
      stockInput.addEventListener('blur', function() {
        setTimeout(() => hideAutocomplete(), 300);
      });
    }
    
    function handleAutocompleteInput(e) {
      const query = e.target.value.trim();
      
      // Clear existing timeout
      if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
      }
      
      // Hide autocomplete if query is too short
      if (query.length < 1) {
        hideAutocomplete();
        return;
      }
      
      // Show loading state immediately
      showAutocompleteLoading();
      
      // Debounce the search to avoid too many API calls
      autocompleteTimeout = setTimeout(() => {
        searchStocks(query);
      }, 300);
    }
    
    async function searchStocks(query) {
      if (!query || query.length < 1) {
        hideAutocomplete();
        return;
      }
      
      try {
        console.log(`Searching for stocks matching: ${query}`);
        
        // Primary: Try Yahoo Finance for real-time, rich results
        try {
          const url = YF_SEARCH_URL(query);
          const response = await fetch(url);
          
          if (response.ok) {
            const wrapper = await response.json();
            if (wrapper.contents) {
              const data = JSON.parse(wrapper.contents);
              
              if (data && data.quotes && Array.isArray(data.quotes) && data.quotes.length > 0) {
                // Filter and process Yahoo suggestions
                const suggestions = data.quotes
                  .filter(quote => {
                    const validTypes = ['EQUITY', 'ETF', 'MUTUALFUND'];
                    return quote.symbol && (validTypes.includes(quote.quoteType) || !quote.quoteType);
                  })
                  .slice(0, 8)
                  .map(quote => ({
                    symbol: quote.symbol,
                    name: quote.longname || quote.shortname || quote.symbol,
                    exchange: quote.exchange || quote.exchDisp || '',
                    type: quote.quoteType || 'EQUITY',
                    typeDisplay: getTypeDisplay(quote.quoteType)
                  }));
                
                if (suggestions.length > 0) {
                  console.log(`Found ${suggestions.length} results from Yahoo Finance`);
                  showAutocompleteSuggestions(suggestions);
                  return;
                }
              }
            }
          }
          
          throw new Error('Yahoo Finance search failed or returned no results');
          
        } catch (yahooError) {
          console.warn('Yahoo Finance search failed:', yahooError.message);
          
          // Fallback: Use local CBOE symbol cache
          console.log('Falling back to local symbol search...');
          
          // Ensure symbol cache is loaded
          const cache = await loadSymbolCache();
          if (cache && cache.length > 0) {
            const localResults = searchLocalSymbols(query);
            
            if (localResults.length > 0) {
              console.log(`Found ${localResults.length} results from local cache`);
              showAutocompleteSuggestions(localResults);
              return;
            }
          }
          
          // If both fail, show no results
          showNoResults(query);
        }
        
      } catch (error) {
        console.error('Complete search failure:', error);
        showAutocompleteError();
      }
    }
    
    function getTypeDisplay(quoteType) {
      const typeMap = {
        'EQUITY': 'Stock',
        'ETF': 'ETF',
        'MUTUALFUND': 'Fund',
        'INDEX': 'Index',
        'CURRENCY': 'Currency',
        'CRYPTOCURRENCY': 'Crypto'
      };
      return typeMap[quoteType] || 'Stock';
    }
    
    function showAutocompleteLoading() {
      const autocompleteContainer = document.getElementById('stockAutocomplete');
      if (!autocompleteContainer) return;
      
      autocompleteContainer.innerHTML = `
        <div class="autocomplete-loading">
          <i class="bi bi-search"></i> Searching...
        </div>`;
      autocompleteContainer.style.display = 'block';
      isAutocompleteVisible = true;
      selectedSuggestionIndex = -1;
    }
    
    function showAutocompleteSuggestions(suggestions) {
      const autocompleteContainer = document.getElementById('stockAutocomplete');
      if (!autocompleteContainer) return;
      
      currentSuggestions = suggestions;
      selectedSuggestionIndex = -1;
      
      const suggestionsHtml = suggestions.map((suggestion, index) => {
        const exchangeText = suggestion.exchange ? ` • ${suggestion.exchange}` : '';
        
        return `
          <div class="stock-suggestion" data-index="${index}">
            <div class="stock-suggestion-symbol">
              ${suggestion.symbol}
              <span class="stock-suggestion-type">${suggestion.typeDisplay}</span>
            </div>
            <div class="stock-suggestion-name">${suggestion.name}</div>
            ${suggestion.exchange ? `<div class="stock-suggestion-exchange">${suggestion.exchange}</div>` : ''}
          </div>`;
      }).join('');
      
      autocompleteContainer.innerHTML = suggestionsHtml;
      autocompleteContainer.style.display = 'block';
      isAutocompleteVisible = true;
      
      // Add event listeners as backup
      const suggestionElements = autocompleteContainer.querySelectorAll('.stock-suggestion');
      suggestionElements.forEach((element, index) => {
        element.addEventListener('click', function(e) {
          e.preventDefault();
          e.stopPropagation();
          console.log('Clicked suggestion:', index, suggestions[index]);
          selectSuggestionByIndex(index);
        });
      });
    }
    
    function showNoResults(query) {
      const autocompleteContainer = document.getElementById('stockAutocomplete');
      if (!autocompleteContainer) return;
      
      autocompleteContainer.innerHTML = `
        <div class="autocomplete-loading">
          <i class="bi bi-x-circle"></i> No stocks found for "${query}"
        </div>`;
      autocompleteContainer.style.display = 'block';
      isAutocompleteVisible = true;
      currentSuggestions = [];
      selectedSuggestionIndex = -1;
    }
    
    function showAutocompleteError() {
      const autocompleteContainer = document.getElementById('stockAutocomplete');
      if (!autocompleteContainer) return;
      
      autocompleteContainer.innerHTML = `
        <div class="autocomplete-loading">
          <i class="bi bi-exclamation-triangle"></i> Search temporarily unavailable
        </div>`;
      autocompleteContainer.style.display = 'block';
      isAutocompleteVisible = true;
      currentSuggestions = [];
      selectedSuggestionIndex = -1;
    }
    
    function hideAutocomplete() {
      const autocompleteContainer = document.getElementById('stockAutocomplete');
      if (!autocompleteContainer) return;
      
      autocompleteContainer.style.display = 'none';
      isAutocompleteVisible = false;
      currentSuggestions = [];
      selectedSuggestionIndex = -1;
    }
    
    function updateSuggestionSelection() {
      const suggestions = document.querySelectorAll('.stock-suggestion');
      suggestions.forEach((suggestion, index) => {
        suggestion.classList.toggle('active', index === selectedSuggestionIndex);
      });
      
      // Update input value with selected suggestion
      if (selectedSuggestionIndex >= 0 && currentSuggestions[selectedSuggestionIndex]) {
        // Optional: Don't auto-fill, just highlight
        // const stockInput = document.getElementById('stockInput');
        // stockInput.value = currentSuggestions[selectedSuggestionIndex].symbol;
      }
    }
    
    function selectSuggestionByIndex(index) {
      console.log('selectSuggestionByIndex called with index:', index);
      if (currentSuggestions[index]) {
        selectSuggestion(currentSuggestions[index]);
      }
    }
    
    function selectSuggestion(suggestion) {
      console.log('selectSuggestion called with:', suggestion);
      const stockInput = document.getElementById('stockInput');
      if (!stockInput) return;
      
      stockInput.value = suggestion.symbol;
      hideAutocomplete();
      
      // Optionally trigger form submission
      // addStockForm.dispatchEvent(new Event('submit'));
      
      // Focus back to input
      stockInput.focus();
    }
    
    // Make functions available globally for onclick handlers
    window.selectSuggestionByIndex = selectSuggestionByIndex;
    window.selectSuggestion = selectSuggestion;
    
    // --- Smart Alert Configuration ---
    
    // Smart Alert settings with defaults
    let smartAlertsEnabled = localStorage.getItem('smartAlertsEnabled') === 'true';
    let smartAlertBuyThresholdValue = Number(localStorage.getItem('smartAlertBuyThreshold')) || 75;
    let smartAlertSellThresholdValue = Number(localStorage.getItem('smartAlertSellThreshold')) || 25;
    let smartAlertEmailEnabled = localStorage.getItem('smartAlertEmailEnabled') === 'true';
    
    // Setup Smart Alert toggle functionality
    function setupSmartAlertToggle() {
      if (!smartAlertsSwitch || !smartAlertSettings) return;
      
      // Toggle settings visibility
      smartAlertsSwitch.addEventListener('change', function() {
        if (this.checked) {
          smartAlertSettings.style.display = 'block';
        } else {
          smartAlertSettings.style.display = 'none';
        }
      });
      
      // Initialize state
      smartAlertsSwitch.checked = smartAlertsEnabled;
      smartAlertSettings.style.display = smartAlertsEnabled ? 'block' : 'none';
      
      if (smartAlertBuyThreshold) smartAlertBuyThreshold.value = smartAlertBuyThresholdValue;
      if (smartAlertSellThreshold) smartAlertSellThreshold.value = smartAlertSellThresholdValue;
      if (smartAlertEmailSwitch) smartAlertEmailSwitch.checked = smartAlertEmailEnabled;
    }
    
    // Check if Smart Score meets alert criteria
    function checkSmartScoreAlerts(symbol, smartScore) {
      if (!smartAlertsEnabled || !smartScore) return;
      
      const { score, sentiment, confidence } = smartScore;
      
      // Only trigger alerts for medium/high confidence signals
      if (confidence === 'low') return;
      
      let shouldAlert = false;
      let alertType = '';
      let alertMessage = '';
      
      // Check buy threshold
      if (score >= smartAlertBuyThresholdValue && sentiment === 'bullish') {
        shouldAlert = true;
        alertType = 'buy';
        alertMessage = `${symbol}: Smart Score ${score} - ${sentiment.toUpperCase()} signal (${confidence} confidence)`;
      }
      
      // Check sell threshold
      if (score <= smartAlertSellThresholdValue && sentiment === 'bearish') {
        shouldAlert = true;
        alertType = 'sell';
        alertMessage = `${symbol}: Smart Score ${score} - ${sentiment.toUpperCase()} signal (${confidence} confidence)`;
      }
      
      if (shouldAlert) {
        // Show browser notification
        showSmartAlert(symbol, alertType, alertMessage, smartScore);
        
        // Send email if enabled
        if (smartAlertEmailEnabled && userEmailInput && userEmailInput.value) {
          sendSmartAlertEmail(symbol, alertType, alertMessage, smartScore);
        }
      }
    }
    
    // Show Smart Alert notification
    function showSmartAlert(symbol, type, message, smartScore) {
      // Browser notification
      if ('Notification' in window && Notification.permission === 'granted') {
        const icon = type === 'buy' ? '🟢' : '🔴';
        new Notification(`${icon} Smart Alert - ${symbol}`, {
          body: message,
          icon: '/favicon.ico',
          tag: `smart-alert-${symbol}`,
          requireInteraction: true
        });
      }
      
      // In-app toast notification
      showToast(message, type === 'buy' ? 'success' : 'warning');
      
      // Console log for debugging
      console.log(`Smart Alert [${type.toUpperCase()}]:`, message);
    }
    
    // Send Smart Alert email
    async function sendSmartAlertEmail(symbol, type, message, smartScore) {
      if (!window.emailjs) return;
      
      const userEmail = userEmailInput.value.trim();
      if (!userEmail) return;
      
      try {
        const emailData = {
          to_email: userEmail,
          subject: `Smart Alert: ${symbol} - ${type.toUpperCase()} Signal`,
          message: message,
          symbol: symbol,
          score: smartScore.score,
          sentiment: smartScore.sentiment,
          confidence: smartScore.confidence,
          signals: smartScore.signals.map(s => `${s.indicator}: ${s.reason}`).join('\n'),
          timestamp: new Date().toLocaleString()
        };
        
        await emailjs.send('service_id', 'template_id', emailData);
        console.log('Smart Alert email sent successfully');
      } catch (error) {
        console.error('Failed to send Smart Alert email:', error);
      }
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast align-items-center text-white bg-${type} border-0`;
      toast.setAttribute('role', 'alert');
      toast.setAttribute('aria-live', 'assertive');
      toast.setAttribute('aria-atomic', 'true');
      
      toast.innerHTML = `
        <div class="d-flex">
          <div class="toast-body">
            ${message}
          </div>
          <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
        </div>
      `;
      
      // Add to toast container (create if doesn't exist)
      let toastContainer = document.getElementById('toastContainer');
      if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toastContainer';
        toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';
        toastContainer.style.zIndex = '9999';
        document.body.appendChild(toastContainer);
      }
      
      toastContainer.appendChild(toast);
      
      // Show toast
      const bsToast = new bootstrap.Toast(toast, { autohide: true, delay: 5000 });
      bsToast.show();
      
      // Remove toast element after it's hidden
      toast.addEventListener('hidden.bs.toast', () => {
        toast.remove();
      });
    }
    
    // Request notification permission on page load
    function requestNotificationPermission() {
      if ('Notification' in window && Notification.permission === 'default') {
        Notification.requestPermission().then(permission => {
          console.log('Notification permission:', permission);
        });
      }
    }
    
    // --- CBOE Symbol Cache System ---
    async function loadSymbolCache() {
      try {
        // Check if we have a valid cache
        const now = Date.now();
        if (symbolCache && cacheTimestamp && (now - cacheTimestamp) < SYMBOL_CACHE_DURATION) {
          console.log('Using cached symbol data');
          return symbolCache;
        }
        
        console.log('Loading CBOE symbol data...');
        const response = await fetch(CBOE_SYMBOLS_URL);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch CBOE data: ${response.status}`);
        }
        
        const csvText = await response.text();
        symbolCache = parseSymbolCSV(csvText);
        cacheTimestamp = now;
        
        // Store in localStorage for persistence
        localStorage.setItem('symbolCache', JSON.stringify(symbolCache));
        localStorage.setItem('symbolCacheTimestamp', cacheTimestamp.toString());
        
        console.log(`Loaded ${symbolCache.length} symbols from CBOE`);
        return symbolCache;
        
      } catch (error) {
        console.warn('Failed to load CBOE symbol data:', error);
        
        // Try to load from localStorage
        const cached = localStorage.getItem('symbolCache');
        const cachedTime = localStorage.getItem('symbolCacheTimestamp');
        
        if (cached && cachedTime) {
          symbolCache = JSON.parse(cached);
          cacheTimestamp = parseInt(cachedTime);
          console.log('Using stored symbol cache as fallback');
          return symbolCache;
        }
        
        return [];
      }
    }
    
    function parseSymbolCSV(csvText) {
      const lines = csvText.split('\n');
      const symbols = [];
      
      // Skip header row, process each line
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const columns = line.split(',');
        if (columns.length >= 2) {
          const symbol = columns[0].replace(/"/g, '').trim();
          const name = columns[1].replace(/"/g, '').trim();
          
          if (symbol && name && symbol.length <= 10) {
            symbols.push({
              symbol: symbol.toUpperCase(),
              name: name,
              exchange: 'US',
              type: 'EQUITY',
              typeDisplay: 'Stock'
            });
          }
        }
      }
      
      return symbols;
    }
    
    function searchLocalSymbols(query) {
      if (!symbolCache || !query) return [];
      
      const upperQuery = query.toUpperCase();
      const matches = [];
      
      for (const symbol of symbolCache) {
        // Match symbol or company name
        if (symbol.symbol.includes(upperQuery) || 
            symbol.name.toUpperCase().includes(upperQuery)) {
          matches.push(symbol);
          
          // Limit results
          if (matches.length >= 8) break;
        }
      }
      
      // Sort by relevance: exact symbol match first, then starts with, then contains
      return matches.sort((a, b) => {
        const aSymbol = a.symbol;
        const bSymbol = b.symbol;
        
        if (aSymbol === upperQuery && bSymbol !== upperQuery) return -1;
        if (bSymbol === upperQuery && aSymbol !== upperQuery) return 1;
        if (aSymbol.startsWith(upperQuery) && !bSymbol.startsWith(upperQuery)) return -1;
        if (bSymbol.startsWith(upperQuery) && !aSymbol.startsWith(upperQuery)) return 1;
        
        return aSymbol.localeCompare(bSymbol);
      });
    }
    addStockForm.onsubmit = async e => {
      e.preventDefault();
      const symbol = stockInput.value.trim().toUpperCase();
      if (!symbol) return;
      let stocks = getTrackedStocks();
      // Check if symbol already exists (handle both string and object formats)
      const symbolExists = stocks.some(s => (typeof s === 'object' ? s.symbol : s) === symbol);
      if (!symbolExists) {
        stocks.push(symbol);
        setTrackedStocks(stocks);
        stockInput.value = '';
        
        // Update tabs immediately to show new count
        renderWatchlistTabs();
        
        // Render stocks immediately to show placeholder
        await renderStocks(true); // Skip automatic data update
        
        // Force fetch historical data for the new stock only
        await fetchNewStockData(symbol);
        
        // Update cache status
        updateCacheStatus();
      }
    };

    // Fetch data for a newly added stock
    async function fetchNewStockData(symbol) {
      try {
        // Show loading state for this specific stock
        const priceEl = document.getElementById(`${symbol}-price`);
        if (priceEl) priceEl.textContent = 'Loading...';
        
        console.log(`Fetching initial data for new stock: ${symbol}`);
        
        // Force full historical data fetch for new stock (ignore cache)
        const historicalKey = `historical_${symbol}`;
        const historicalTimestampKey = `historical_${symbol}_timestamp`;
        
        // Remove any existing cache for this symbol to force fresh fetch
        localStorage.removeItem(historicalKey);
        localStorage.removeItem(historicalTimestampKey);
        
        // Fetch fresh data (will be full 200d range since no cache exists)
        const data = await fetchStockData(symbol);
        
        if (data) {
          // Update cache with new data
          currentDataCache[symbol] = data;
          saveCurrentDataToStorage(currentDataCache);

          // Save company name and market cap to tracked stock object if available
          let stocks = getTrackedStocks();
          // Find index of symbol (string or object)
          let idx = stocks.findIndex(s => (typeof s === 'object' ? s.symbol === symbol : s === symbol));
          let updated = false;
          if (idx !== -1) {
            let stockObj = typeof stocks[idx] === 'object' ? stocks[idx] : { symbol: stocks[idx] };
            if (data.longName) {
              stockObj.name = data.longName;
              updated = true;
            } else if (data.companyName) {
              stockObj.name = data.companyName;
              updated = true;
            }
            if (data.marketCap !== undefined) {
              stockObj.marketCap = data.marketCap;
              updated = true;
            }
            if (updated) {
              stocks[idx] = stockObj;
              setTrackedStocks(stocks);
            }
          }

          // Update UI for this stock
          updateSingleStockDisplay(symbol, data);

          console.log(`Successfully loaded initial data for new stock: ${symbol}`);
        } else {
          // Handle error case
          if (priceEl) priceEl.textContent = 'Error';
          const fetchError = document.getElementById('fetchError');
          fetchError.textContent = `Failed to load data for ${symbol}. Please check the symbol.`;
          fetchError.style.display = '';
        }
      } catch (error) {
        console.error(`Error fetching data for new stock ${symbol}:`, error);
        const priceEl = document.getElementById(`${symbol}-price`);
        if (priceEl) priceEl.textContent = 'Error';
      }
    }

    // Helper function to update alert badge on bell icons
    function updateAlertBadge(bellElement, alertCount) {
      if (!bellElement) return;
      
      let countLabel = bellElement.querySelector('.alert-count');
      if (!countLabel && alertCount > 0) {
        // Create the badge element
        countLabel = document.createElement('span');
        countLabel.className = 'alert-count';
        bellElement.style.position = 'relative';
        bellElement.appendChild(countLabel);
      }
      
      if (countLabel) {
        if (alertCount > 0) {
          countLabel.textContent = alertCount;
          countLabel.style.display = '';
        } else {
          countLabel.style.display = 'none';
        }
      }
    }

    // Update display for a single stock
    function updateSingleStockDisplay(symbol, data) {
      // Update card border color based on price direction (for card view)
      const cardElement = document.querySelector(`[data-symbol="${symbol}"] .card`);
      if (cardElement && !isTableView) {
        cardElement.classList.remove('border-success', 'border-danger');
        if (data.priceDir === 'up') {
          cardElement.classList.add('border-success');
        } else if (data.priceDir === 'down') {
          cardElement.classList.add('border-danger');
        }
      }
      
      // --- Update Company Name (Table View) ---
      const companyNameEl = document.getElementById(`${symbol}-companyNameText`);
      if (companyNameEl) {
        let companyName = '';
        // Get tracked stocks and find object
        let stocks = getTrackedStocks();
        let found = stocks.find(s => (typeof s === 'object' && s.symbol === symbol));
        if (found && found.name) {
          companyName = found.name;
        } else if (data.companyName) {
          companyName = data.companyName;
        } else {
          // Try to get company name from symbol cache
          if (window.symbolCache && Array.isArray(window.symbolCache)) {
            const match = window.symbolCache.find(s => s.symbol === symbol);
            if (match && match.name) {
              companyName = match.name;
            }
          }
          // If found, update tracked stock object for future renders
          if (companyName && found) {
            found.name = companyName;
            setTrackedStocks(stocks);
          }
        }
        companyNameEl.textContent = companyName || symbol;
      }
      
      // --- Alert indicator (card view) ---
      const alertBellEl = document.getElementById(`${symbol}-alertBell`);
      const alertBellTableEl = document.getElementById(`${symbol}-alertBell-table`);
      const alertCount = getAlerts(symbol).length;
      
      // Update card view alert bell
      if (alertBellEl) {
        if (alertCount > 0) {
          alertBellEl.classList.add('active');
          alertBellEl.title = `View ${alertCount} alert${alertCount > 1 ? 's' : ''}`;
        } else {
          alertBellEl.classList.remove('active');
          alertBellEl.title = 'Add alert';
        }
        // Add/update alert count badge
        updateAlertBadge(alertBellEl, alertCount);
      }
      
      // Update table view alert bell
      if (alertBellTableEl) {
        if (alertCount > 0) {
          alertBellTableEl.classList.add('active');
          alertBellTableEl.title = `View ${alertCount} alert${alertCount > 1 ? 's' : ''}`;
        } else {
          alertBellTableEl.classList.remove('active');
          alertBellTableEl.title = 'Add alert';
        }
        // Add/update alert count badge
        updateAlertBadge(alertBellTableEl, alertCount);
      }
      // Price
      const priceEl = document.getElementById(`${symbol}-price`);
      const pricePctEl = document.getElementById(`${symbol}-pricePct`);
      const priceDirEl = document.getElementById(`${symbol}-priceDir`);
      const sparkEl = document.getElementById(`${symbol}-spark`);
      // High/Low
      const highlowEl = document.getElementById(`${symbol}-highlow`);
      // Volume
      const volumeEl = document.getElementById(`${symbol}-volume`);
      const volPctEl = document.getElementById(`${symbol}-volPct`);
      const volDirEl = document.getElementById(`${symbol}-volDir`);
      const avgvolEl = document.getElementById(`${symbol}-avgvol`);
      const avgvolTableEl = document.getElementById(`${symbol}-avgvol-table`);
      // RSI
      const rsiEl = document.getElementById(`${symbol}-rsi`);
      const rsiDirEl = document.getElementById(`${symbol}-rsiDir`);
      // MA50
      const ma50El = document.getElementById(`${symbol}-ma50`);
      const ma50DirEl = document.getElementById(`${symbol}-ma50Dir`);
      // MA150
      const ma150El = document.getElementById(`${symbol}-ma150`);
      const maDirEl = document.getElementById(`${symbol}-maDir`);
      // MA200
      const ma200El = document.getElementById(`${symbol}-ma200`);
      const ma200DirEl = document.getElementById(`${symbol}-ma200Dir`);
      // ATR(14)
      const atr14El = document.getElementById(`${symbol}-atr14`);
      const atr14IndEl = document.getElementById(`${symbol}-atr14Ind`);
      // Market Cap
      const marketCapEl = document.getElementById(`${symbol}-marketCap`);
      // Last updated
      const updatedEl = document.getElementById(`${symbol}-updated`);

      // Price
      if (priceEl) priceEl.textContent = data.price?.toFixed(2) ?? '-';
      if (pricePctEl) {
        pricePctEl.textContent = data.pricePct !== null ? '(' + (data.pricePct > 0 ? '+' : '') + data.pricePct.toFixed(2) + '%)' : '';
        pricePctEl.className = data.priceDir;
      }
      if (priceDirEl) {
        priceDirEl.textContent = data.priceDir === 'up' ? '▲' : data.priceDir === 'down' ? '▼' : '';
        priceDirEl.className = data.priceDir;
      }
      // Sparkline
      if (sparkEl && Array.isArray(data.sparkData)) {
        sparkEl.innerHTML = renderSparkline(data.sparkData);
      }
      // High/Low
      if (highlowEl) {
        if (data.todayHigh && data.todayLow) {
          highlowEl.textContent = data.todayHigh.toFixed(2) + ' / ' + data.todayLow.toFixed(2);
        } else {
          highlowEl.textContent = '-';
        }
      }
      // Volume - Enhanced with average comparison
      if (volumeEl) {
        let volumeText = humanVolume(data.volume);
        
        // Add volume vs average indicator
        if (data.volume && data.avgVol50) {
          const volRatio = data.volume / data.avgVol50;
          if (volRatio > 2.0) volumeText += ' 🔥'; // Very high volume
          else if (volRatio > 1.5) volumeText += ' ⬆️'; // High volume  
          else if (volRatio < 0.5) volumeText += ' ⬇️'; // Low volume
        }
        
        volumeEl.textContent = volumeText;
      }
      if (volPctEl) {
        volPctEl.textContent = data.volPct !== null ? '(' + (data.volPct > 0 ? '+' : '') + data.volPct.toFixed(2) + '%)' : '';
        volPctEl.className = data.volDir;
      }
      if (volDirEl) {
        volDirEl.textContent = data.volDir === 'up' ? '▲' : data.volDir === 'down' ? '▼' : '';
        volDirEl.className = data.volDir;
      }
      // Avg volume 50d (separate row) - Enhanced comparison
      if (avgvolEl) {
        if (data.avgVol50) {
          const volVsAvg = data.volume && data.avgVol50 ? ((data.volume - data.avgVol50) / data.avgVol50) * 100 : null;
          let volVsAvgText = '';
          let volVsAvgClass = 'neutral';
          
          if (volVsAvg !== null) {
            volVsAvgText = ` (${volVsAvg > 0 ? '+' : ''}${volVsAvg.toFixed(1)}% vs avg)`;
            if (volVsAvg > 50) volVsAvgClass = 'up';
            else if (volVsAvg < -30) volVsAvgClass = 'down';
            else volVsAvgClass = 'neutral';
          }
          
          avgvolEl.textContent = humanVolume(data.avgVol50) + volVsAvgText;
          avgvolEl.className = volVsAvgClass;
        } else {
          avgvolEl.textContent = '-';
          avgvolEl.className = 'neutral';
        }
      }
      
      // Avg volume 50d (table view)
      if (avgvolTableEl) {
        if (data.avgVol50) {
          avgvolTableEl.textContent = humanVolume(data.avgVol50);
          avgvolTableEl.className = 'neutral';
        } else {
          avgvolTableEl.textContent = '-';
          avgvolTableEl.className = 'neutral';
        }
      }
      // ATR(14)
      if (atr14El) atr14El.textContent = data.atr14 ? data.atr14.toFixed(2) : '-';
      // ATR(14) percent of price
      const atr14PctEl = document.getElementById(`${symbol}-atr14Pct`);
      if (atr14PctEl) {
        if (data.atr14 && data.price) {
          const pct = (data.atr14 / data.price) * 100;
          atr14PctEl.textContent = `(${pct.toFixed(2)}%)`;
          
          // Color code based on ATR percentage levels
          if (pct < 3) {
            atr14PctEl.className = 'up'; // Green for low volatility
          } else if (pct >= 3 && pct < 6) {
            atr14PctEl.className = 'warning'; // Orange for medium volatility
          } else {
            atr14PctEl.className = 'down'; // Red for high volatility
          }
        } else {
          atr14PctEl.textContent = '';
          atr14PctEl.className = 'neutral';
        }
      }
      if (atr14IndEl) {
        // Clear ATR indicator arrows since we use color coding instead
        atr14IndEl.textContent = '';
        atr14IndEl.className = 'neutral';
      }
      
      // ATR(14) for details section (duplicate values with unique IDs)
      const atr14DetailsEl = document.getElementById(`${symbol}-atr14-details`);
      const atr14PctDetailsEl = document.getElementById(`${symbol}-atr14Pct-details`);
      const atr14IndDetailsEl = document.getElementById(`${symbol}-atr14Ind-details`);
      
      if (atr14DetailsEl) atr14DetailsEl.textContent = data.atr14 ? data.atr14.toFixed(2) : '-';
      if (atr14PctDetailsEl) {
        if (data.atr14 && data.price) {
          const pct = (data.atr14 / data.price) * 100;
          atr14PctDetailsEl.textContent = `(${pct.toFixed(2)}%)`;
          
          // Apply color coding based on volatility
          if (pct < atrLowThresh) {
            atr14PctDetailsEl.className = 'up'; // Green for low volatility
          } else if (pct <= atrHighThresh) {
            atr14PctDetailsEl.className = 'warning'; // Orange for medium volatility
          } else {
            atr14PctDetailsEl.className = 'down'; // Red for high volatility
          }
        } else {
          atr14PctDetailsEl.textContent = '';
          atr14PctDetailsEl.className = 'neutral';
        }
      }
      if (atr14IndDetailsEl) {
        // Clear ATR indicator arrows since we use color coding instead
        atr14IndDetailsEl.textContent = '';
        atr14IndDetailsEl.className = 'neutral';
      }
      
      // Market Cap
      if (marketCapEl) {
        console.log(`[${symbol}] Displaying market cap. data.marketCap value:`, data.marketCap, typeof data.marketCap);
        if (data.marketCap === undefined) {
          marketCapEl.textContent = 'N/A';
          console.log(`[${symbol}] Market cap set to N/A (undefined)`);
        } else if (data.marketCap === null) {
          marketCapEl.textContent = '-';
          console.log(`[${symbol}] Market cap set to - (null, ETF)`);
        } else {
          const cap = data.marketCap;
          if (cap >= 1e12) {
            marketCapEl.textContent = `${(cap / 1e12).toFixed(2)}T`;
          } else if (cap >= 1e9) {
            marketCapEl.textContent = `${(cap / 1e9).toFixed(2)}B`;
          } else if (cap >= 1e6) {
            marketCapEl.textContent = `${(cap / 1e6).toFixed(2)}M`;
          } else if (cap >= 1e3) {
            marketCapEl.textContent = `${(cap / 1e3).toFixed(2)}K`;
          } else {
            marketCapEl.textContent = cap.toFixed(0);
          }
          console.log(`[${symbol}] Market cap displayed as:`, marketCapEl.textContent);
        }
      } else {
        console.log(`[${symbol}] Market cap element not found!`);
      }
      
      // Stop Loss (price - ATR)
      const stoplossEl = document.getElementById(`${symbol}-stoploss`);
      if (stoplossEl) {
        if (data.price && data.atr14) {
          const stop = data.price - data.atr14;
          stoplossEl.textContent = stop.toFixed(2);
        } else {
          stoplossEl.textContent = '-';
        }
      }
      
      // Target Price
      const targetPriceEl = document.getElementById(`${symbol}-targetprice`);
      if (targetPriceEl) {
        if (data.targetPrice) {
          targetPriceEl.textContent = data.targetPrice.toFixed(2);
          targetPriceEl.className = 'up'; // Green for target price
        } else {
          targetPriceEl.textContent = '-';
          targetPriceEl.className = 'neutral';
        }
      }
      
      // Support Level
      const supportEl = document.getElementById(`${symbol}-support`);
      if (supportEl) {
        if (data.supportLevel) {
          supportEl.textContent = data.supportLevel.toFixed(2);
          supportEl.className = 'warning'; // Orange for support level
        } else {
          supportEl.textContent = '-';
          supportEl.className = 'neutral';
        }
      }
      
      // Volume Strength
      const volStrengthEl = document.getElementById(`${symbol}-volstrength`);
      if (volStrengthEl) {
        if (data.volumeStrength) {
          volStrengthEl.textContent = data.volumeStrength;
          // Color coding for volume strength
          if (data.volumeStrength.includes('Very High') || data.volumeStrength.includes('High')) {
            volStrengthEl.className = 'up';
          } else if (data.volumeStrength.includes('Low')) {
            volStrengthEl.className = 'down';
          } else {
            volStrengthEl.className = 'neutral';
          }
        } else {
          volStrengthEl.textContent = '-';
          volStrengthEl.className = 'neutral';
        }
      }
      
      // Volume Trend
      const volTrendEl = document.getElementById(`${symbol}-voltrend`);
      if (volTrendEl) {
        if (data.volumeTrend) {
          volTrendEl.textContent = data.volumeTrend;
          // Color coding for volume trend
          if (data.volumeTrend === 'Increasing') {
            volTrendEl.className = 'up';
          } else if (data.volumeTrend === 'Decreasing') {
            volTrendEl.className = 'down';
          } else {
            volTrendEl.className = 'neutral';
          }
        } else {
          volTrendEl.textContent = '-';
          volTrendEl.className = 'neutral';
        }
      }
      // CCI(14) with trend indicator
      const cciEl = document.getElementById(`${symbol}-cci`);
      const cciDirEl = document.getElementById(`${symbol}-cciDir`);
      const cciTrendEl = document.getElementById(`${symbol}-cciTrend`);
      const cciDaysEl = document.getElementById(`${symbol}-cciDays`);
      
      if (cciEl) cciEl.textContent = (typeof data.cci === 'number' && !isNaN(data.cci)) ? data.cci.toFixed(2) : '-';
      if (cciDirEl) {
        cciDirEl.textContent = data.cciDir === 'up' ? '▲' : data.cciDir === 'down' ? '▼' : '';
        cciDirEl.className = data.cciDir || 'neutral';
      }
      
      // Enhanced CCI trend indicator for table view
      if (cciTrendEl) {
        if (typeof data.cci === 'number' && !isNaN(data.cci)) {
          const cciTrend = getCCITrend(data.cci, data.previousCCI || data.cci);
          cciTrendEl.textContent = cciTrend.symbol;
          cciTrendEl.className = cciTrend.class;
          cciTrendEl.title = `CCI: ${cciTrend.condition} (${cciTrend.direction})`;
        } else {
          cciTrendEl.textContent = '';
          cciTrendEl.className = 'neutral';
        }
      }
      
      if (cciDaysEl) cciDaysEl.textContent = data.cciDays || '';
      // Earnings days
      const earningsEl = document.getElementById(`${symbol}-earnings`);
      if (earningsEl) {
        if (typeof data.earningsDays === 'number' && !isNaN(data.earningsDays)) {
          earningsEl.textContent = data.earningsDays + ' days remaining';
        } else {
          earningsEl.textContent = '-';
        }
      }
      // Last updated
      if (updatedEl) {
        const now = Date.now();
        const age = now - data.lastUpdated;
        let txt = '';
        if (age < 60000) txt = 'Just now';
        else if (age < 3600000) txt = Math.round(age/60000) + ' min ago';
        else txt = new Date(data.lastUpdated).toLocaleTimeString();
        updatedEl.textContent = txt;
        updatedEl.className = 'neutral'; // Always use neutral color for last updated
      }

      // --- Check alerts and notify if triggered ---
      const alerts = getAlerts(symbol);
      alerts.forEach(alert => {
        let val = data[alert.field];
        if (val == null) return;
        let triggered = false;
        if (alert.op === '>' && val > alert.value) triggered = true;
        if (alert.op === '<' && val < alert.value) triggered = true;
        if (alert.op === '=' && val == alert.value) triggered = true;
        if (triggered) {
          // Try browser notification, else fallback to alert()
          if (window.Notification && Notification.permission === 'granted') {
            new Notification(`Stock Alert: ${symbol}`,
              { body: `${alert.field} ${alert.op} ${alert.value}` });
          } else if (window.Notification && Notification.permission !== 'denied') {
            Notification.requestPermission().then(p => {
              if (p === 'granted') {
                new Notification(`Stock Alert: ${symbol}`,
                  { body: `${alert.field} ${alert.op} ${alert.value}` });
              } else {
                window.alert(`Stock Alert for ${symbol}: ${alert.field} ${alert.op} ${alert.value}`);
              }
            });
          } else {
            window.alert(`Stock Alert for ${symbol}: ${alert.field} ${alert.op} ${alert.value}`);
          }
          // Send email if user email is set
          const userEmail = localStorage.getItem('userEmail');
          if (userEmail && window.emailjs && emailjs.send) {
            emailjs.send("service_wtzp4kp","template_muzrxdr",{
              stock: symbol,
              email: userEmail,
              field: alert.field,
              op: alert.op,
              value: alert.value
            });
          }
        }
      });
      
      // RSI(14) with trend indicator
      const rsiTrendEl = document.getElementById(`${symbol}-rsiTrend`);
      if (rsiEl) rsiEl.textContent = data.rsi ? data.rsi.toFixed(1) : '-';
      if (rsiDirEl) {
        rsiDirEl.textContent = data.rsiDir === 'up' ? '▲' : data.rsiDir === 'down' ? '▼' : '';
        rsiDirEl.className = data.rsiDir || 'neutral';
      }
      
      // Enhanced RSI trend indicator for table view
      if (rsiTrendEl) {
        if (data.rsi) {
          const rsiTrend = getRSITrend(data.rsi, data.previousRSI || data.rsi);
          rsiTrendEl.textContent = rsiTrend.symbol;
          rsiTrendEl.className = rsiTrend.class;
          rsiTrendEl.title = `RSI: ${rsiTrend.condition} (${rsiTrend.direction})`;
        } else {
          rsiTrendEl.textContent = '';
          rsiTrendEl.className = 'neutral';
        }
      }
      
      // MA50 with trend indicator
      const ma50TrendEl = document.getElementById(`${symbol}-ma50Trend`);
      if (ma50El) ma50El.textContent = data.ma50 ? data.ma50.toFixed(2) : '-';
      if (ma50DirEl) {
        ma50DirEl.textContent = data.ma50Dir === 'up' ? '▲' : data.ma50Dir === 'down' ? '▼' : '';
        ma50DirEl.className = data.ma50Dir;
      }
      if (ma50TrendEl) {
        if (data.ma50 && data.price) {
          const ma50Trend = getMovingAverageTrend(data.price, data.ma50);
          ma50TrendEl.textContent = ma50Trend.symbol;
          ma50TrendEl.className = ma50Trend.class;
          ma50TrendEl.title = `Price ${ma50Trend.text} 50MA`;
        } else {
          ma50TrendEl.textContent = '';
          ma50TrendEl.className = 'neutral';
        }
      }
      
      // MA150 with trend indicator  
      const ma150TrendEl = document.getElementById(`${symbol}-ma150Trend`);
      if (ma150El) ma150El.textContent = data.ma150 ? data.ma150.toFixed(2) : '-';
      if (maDirEl) {
        maDirEl.textContent = data.maDir === 'up' ? '▲' : data.maDir === 'down' ? '▼' : '';
        maDirEl.className = data.maDir;
      }
      if (ma150TrendEl) {
        if (data.ma150 && data.price) {
          const ma150Trend = getMovingAverageTrend(data.price, data.ma150);
          ma150TrendEl.textContent = ma150Trend.symbol;
          ma150TrendEl.className = ma150Trend.class;
          ma150TrendEl.title = `Price ${ma150Trend.text} 150MA`;
        } else {
          ma150TrendEl.textContent = '';
          ma150TrendEl.className = 'neutral';
        }
      }
      
      // MA200 with trend indicator
      const ma200TrendEl = document.getElementById(`${symbol}-ma200Trend`);
      if (ma200El) {
        if (data.ma200 !== null && data.ma200 !== undefined) {
          ma200El.textContent = data.ma200.toFixed(2);
        } else {
          ma200El.textContent = '-';
        }
      }
      if (ma200DirEl) {
        ma200DirEl.textContent = data.ma200Dir === 'up' ? '▲' : data.ma200Dir === 'down' ? '▼' : '';
        ma200DirEl.className = data.ma200Dir;
      }
      if (ma200TrendEl) {
        if (data.ma200 && data.price) {
          const ma200Trend = getMovingAverageTrend(data.price, data.ma200);
          ma200TrendEl.textContent = ma200Trend.symbol;
          ma200TrendEl.className = ma200Trend.class;
          ma200TrendEl.title = `Price ${ma200Trend.text} 200MA`;
        } else {
          ma200TrendEl.textContent = '';
          ma200TrendEl.className = 'neutral';
        }
      }
      
      // --- Smart Score Display ---
      const smartScoreValueEl = document.getElementById(`${symbol}-smartScoreValue`);
      const smartScoreSentimentEl = document.getElementById(`${symbol}-smartScoreSentiment`);
      const smartScoreContainerEl = document.getElementById(`${symbol}-smartScore`);
      
      if (smartScoreValueEl && smartScoreSentimentEl && smartScoreContainerEl && data.smartScore) {
        const { score, sentiment, confidence, signals } = data.smartScore;
        
        // Update value
        smartScoreValueEl.textContent = score;
        
        // Update sentiment
        smartScoreSentimentEl.textContent = `${sentiment} (${confidence})`;
        
        // Update container styling based on sentiment
        smartScoreContainerEl.className = `smart-score-container smart-score-${sentiment}`;
        
        // Create tooltip with signal details
        const signalDetails = signals.map(signal => 
          `${signal.indicator}: ${signal.reason} (${signal.strength.toFixed(0)}%)`
        ).join('\n');
        
        smartScoreContainerEl.title = signalDetails || 'No active signals';
      } else if (smartScoreValueEl && smartScoreSentimentEl && smartScoreContainerEl) {
        // No smart score data - show placeholder
        smartScoreValueEl.textContent = '-';
        smartScoreSentimentEl.textContent = 'N/A';
        smartScoreContainerEl.className = 'smart-score-container smart-score-neutral';
        smartScoreContainerEl.title = 'Insufficient data for Smart Score calculation';
      }
    }

    // Remove stock
    function removeStock(symbol) {
      let stocks = getTrackedStocks();
      stocks = stocks.filter(s => (typeof s === 'object' ? s.symbol : s) !== symbol);
      setTrackedStocks(stocks);
      
      // Clean up cache for removed stock
      localStorage.removeItem(`historical_${symbol}`);
      localStorage.removeItem(`historical_${symbol}_timestamp`);
      
      // Clean up current data cache
      if (currentDataCache[symbol]) {
        delete currentDataCache[symbol];
        saveCurrentDataToStorage(currentDataCache);
      }
      
      // Update tabs immediately to show new count
      renderWatchlistTabs();
      
      renderStocks();
      updateCacheStatus();
    }

    // Drag-and-drop reordering
    let dragSrc = null;
    function handleDragStart(e) {
      dragSrc = this.getAttribute('data-symbol');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', dragSrc);
      this.classList.add('dragging');
    }
    function handleDragOver(e) {
      e.preventDefault();
      this.classList.add('drag-over');
    }
    function handleDragLeave(e) {
      this.classList.remove('drag-over');
    }
    function handleDrop(e) {
      e.preventDefault();
      this.classList.remove('drag-over');
      const targetSymbol = this.getAttribute('data-symbol');
      if (dragSrc && targetSymbol && dragSrc !== targetSymbol) {
        let stocks = getTrackedStocks();
        const from = stocks.indexOf(dragSrc);
        const to = stocks.indexOf(targetSymbol);
        if (from > -1 && to > -1) {
          stocks.splice(to, 0, stocks.splice(from, 1)[0]);
          setTrackedStocks(stocks);
          renderStocks();
        }
      }
      dragSrc = null;
    }
    function handleDragEnd(e) {
      this.classList.remove('dragging');
      const cards = document.querySelectorAll('.stock-card');
      cards.forEach(card => card.classList.remove('drag-over'));
    }

    // ATR(14) thresholds (defaults)
    let atrHighThresh = Number(localStorage.getItem('atrHighThresh')) || 1.5;
    let atrLowThresh = Number(localStorage.getItem('atrLowThresh')) || 0.5;
    
    // View state
    let isTableView = localStorage.getItem('tableView') === '1';
    let tableSortColumn = localStorage.getItem('tableSortColumn') || 'symbol';
    let tableSortDirection = localStorage.getItem('tableSortDirection') || 'asc';
    
    // Cache for historical data to avoid repeated API calls
    let historicalDataCache = {};
    let lastCacheTime = 0;
    const CACHE_DURATION = 15 * 60 * 1000; // 15 minutes for real-time data
    const HISTORICAL_CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours for historical data
    const CURRENT_DATA_CACHE_DURATION = 15 * 60 * 1000; // 15 minutes for current processed data (background update interval)
    const HISTORICAL_CACHE_KEY = 'stockHistoricalData';
    const HISTORICAL_CACHE_TIMESTAMP_KEY = 'stockHistoricalDataTimestamp';
    const CURRENT_DATA_CACHE_KEY = 'stockCurrentData';
    const CURRENT_DATA_TIMESTAMP_KEY = 'stockCurrentDataTimestamp';
    
    // Background update system
    let backgroundUpdateTimer = null;
    let isBackgroundUpdating = false;
    
    // Load historical data from localStorage
    function loadHistoricalDataFromStorage() {
      try {
        const cachedTimestamp = localStorage.getItem(HISTORICAL_CACHE_TIMESTAMP_KEY);
        const now = Date.now();
        
        // If data is less than 24 hours old, load it
        if (cachedTimestamp && (now - parseInt(cachedTimestamp)) < HISTORICAL_CACHE_DURATION) {
          const cachedData = localStorage.getItem(HISTORICAL_CACHE_KEY);
          if (cachedData) {
            console.log('Loading historical data from localStorage (age: ' + Math.round((now - parseInt(cachedTimestamp)) / (60 * 60 * 1000)) + ' hours)');
            return JSON.parse(cachedData);
          }
        } else if (cachedTimestamp) {
          console.log('Historical data expired (age: ' + Math.round((now - parseInt(cachedTimestamp)) / (60 * 60 * 1000)) + ' hours), will fetch new data');
        }
      } catch (e) {
        console.warn('Failed to load historical data from storage:', e);
      }
      return {};
    }
    
    // Save historical data to localStorage
    function saveHistoricalDataToStorage(data) {
      try {
        const now = Date.now();
        localStorage.setItem(HISTORICAL_CACHE_KEY, JSON.stringify(data));
        localStorage.setItem(HISTORICAL_CACHE_TIMESTAMP_KEY, now.toString());
        console.log('Saved historical data to localStorage with timestamp:', new Date(now).toLocaleString());
      } catch (e) {
        console.warn('Failed to save historical data to storage:', e);
      }
    }
    
    // Load current processed data from localStorage
    function loadCurrentDataFromStorage() {
      try {
        const cachedTimestamp = localStorage.getItem(CURRENT_DATA_TIMESTAMP_KEY);
        const cachedData = localStorage.getItem(CURRENT_DATA_CACHE_KEY);
        
        if (cachedData) {
          const now = Date.now();
          if (cachedTimestamp) {
            const age = Math.round((now - parseInt(cachedTimestamp)) / (60 * 1000));
            console.log('Loading current processed data from localStorage (age: ' + age + ' minutes)');
            
            // Always return cached data for immediate display, regardless of age
            // Background updates will refresh stale data
            return JSON.parse(cachedData);
          } else {
            console.log('Loading current processed data from localStorage (no timestamp)');
            return JSON.parse(cachedData);
          }
        }
      } catch (e) {
        console.warn('Failed to load current processed data from storage:', e);
      }
      return {};
    }
    
    // Save current processed data to localStorage
    function saveCurrentDataToStorage(data) {
      try {
        const now = Date.now();
        localStorage.setItem(CURRENT_DATA_CACHE_KEY, JSON.stringify(data));
        localStorage.setItem(CURRENT_DATA_TIMESTAMP_KEY, now.toString());
        console.log('Saved current processed data to localStorage with timestamp:', new Date(now).toLocaleString());
      } catch (e) {
        console.warn('Failed to save current processed data to storage:', e);
      }
    }
    
    // Initialize historical data cache from storage
    let historicalIndicators = loadHistoricalDataFromStorage();
    
    // Initialize current data cache from storage  
    let currentDataCache = loadCurrentDataFromStorage();
    
    // Start background update system
    function startBackgroundUpdates() {
      // Clear any existing timer
      if (backgroundUpdateTimer) {
        clearInterval(backgroundUpdateTimer);
      }
      
      // Start 15-minute background updates
      backgroundUpdateTimer = setInterval(async () => {
        console.log('Starting background update of stock data...');
        await performBackgroundUpdate();
      }, CURRENT_DATA_CACHE_DURATION); // 15 minutes
      
      console.log('Background update system started (15-minute intervals)');
    }
    
    // Perform background API updates
    async function performBackgroundUpdate() {
      if (isBackgroundUpdating) {
        console.log('Background update already in progress, skipping...');
        return;
      }
      
      isBackgroundUpdating = true;
      
      // Always update both stocks and indexes in background
      const stocks = getTrackedStocks();
      const allSymbols = [...new Set([...stocks, ...MAJOR_INDEXES])]; // Remove duplicates if any
      
      if (allSymbols.length === 0) {
        isBackgroundUpdating = false;
        return;
      }
      
      console.log(`Background updating ${allSymbols.length} symbols (${stocks.length} stocks + ${MAJOR_INDEXES.length} indexes)...`);
      let updatedCount = 0;
      let errorCount = 0;

      // Run all fetches in parallel
      const fetchPromises = allSymbols.map(async symbol => {
        try {
          const stockData = await fetchStockData(symbol);
          if (stockData) {
            currentDataCache[symbol] = stockData;
            updatedCount++;
            console.log(`Background updated ${symbol}`);
          } else {
            errorCount++;
            console.warn(`Background update failed for ${symbol}`);
          }
        } catch (error) {
          errorCount++;
          console.error(`Background update error for ${symbol}:`, error);
        }
      });

      await Promise.all(fetchPromises);

      // Save updated data to storage
      if (updatedCount > 0) {
        saveCurrentDataToStorage(currentDataCache);
        console.log(`Background update completed: ${updatedCount} updated, ${errorCount} errors`);
        // Update UI with fresh data from storage
        await updateUIFromStorage();
      } else {
        console.log('Background update completed with no successful updates');
      }

      isBackgroundUpdating = false;
    }
    
    // Update UI from localStorage data only
    async function updateUIFromStorage() {
      console.log('Updating UI from localStorage data...');
      
      if (currentViewMode === 'indexes') {
        // Update indexes (always card view)
        for (const symbol of MAJOR_INDEXES) {
          const data = currentDataCache[symbol];
          if (data) {
            const indexName = INDEX_NAMES[symbol] || symbol;
            updateIndexCard(symbol, indexName, data);
          }
        }
      } else {
        // Update stocks
        const stocks = getTrackedStocks();
        for (const stock of stocks) {
          const symbol = typeof stock === 'object' ? stock.symbol : stock;
          const data = currentDataCache[symbol];
          if (data) {
            updateSingleStockDisplay(symbol, data);
          }
        }
      }
      
      // Update cache status
      updateCacheStatus();
      
      // Re-sort table if in table view (only for stocks)
      if (isTableView && currentViewMode === 'watchlist') {
        resortTableRows();
      }
      
      console.log('UI updated from storage');
    }
    
    // Helper function to format date for Polygon API
    function formatDate(date) {
      return date.toISOString().split('T')[0];
    }
    
    // Helper function to get date X days ago
    function getDaysAgo(days) {
      const date = new Date();
      date.setDate(date.getDate() - days);
      return date;
    }
    
    // Table sorting function
    function sortTable(column) {
      if (tableSortColumn === column) {
        tableSortDirection = tableSortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        tableSortColumn = column;
        tableSortDirection = 'asc';
      }
      localStorage.setItem('tableSortColumn', tableSortColumn);
      localStorage.setItem('tableSortDirection', tableSortDirection);
      
      // Only re-sort existing table rows, don't fetch new data
      if (isTableView) {
        resortTableRows();
        updateTableHeaders(); // Update sort indicators in headers
      }
    }
    
    // Get sortable stocks data (for table view)
    function getSortableStocksData() {
      const stocks = getTrackedStocks();
      const stocksData = [];
      
      stocks.forEach(stock => {
        const symbol = typeof stock === 'object' ? stock.symbol : stock;
        const priceEl = document.getElementById(`${symbol}-price`);
        const rsiEl = document.getElementById(`${symbol}-rsi`);
        const ma50El = document.getElementById(`${symbol}-ma50`);
        const ma200El = document.getElementById(`${symbol}-ma200`);
        const atr14El = document.getElementById(`${symbol}-atr14`);
        const volumeEl = document.getElementById(`${symbol}-volume`);
        const pricePctEl = document.getElementById(`${symbol}-pricePct`);
        const smartScoreEl = document.getElementById(`${symbol}-smartScoreValue`);
        const marketCapEl = document.getElementById(`${symbol}-marketCap`);
        
        const price = priceEl ? parseFloat(priceEl.textContent) || 0 : 0;
        const rsi = rsiEl ? parseFloat(rsiEl.textContent) || 0 : 0;
        const ma50 = ma50El ? parseFloat(ma50El.textContent) || 0 : 0;
        const ma200 = ma200El ? parseFloat(ma200El.textContent) || 0 : 0;
        const atr = atr14El ? parseFloat(atr14El.textContent) || 0 : 0;
        const smartScore = smartScoreEl ? parseFloat(smartScoreEl.textContent) || 0 : 0;
        
        // Parse volume (handle K, M, B suffixes)
        let volume = 0;
        if (volumeEl) {
          const volText = volumeEl.textContent.replace(/[^0-9.KMB]/g, '');
          const volNum = parseFloat(volText) || 0;
          if (volText.includes('B')) volume = volNum * 1e9;
          else if (volText.includes('M')) volume = volNum * 1e6;
          else if (volText.includes('K')) volume = volNum * 1e3;
          else volume = volNum;
        }
        
        // Parse market cap (handle K, M, B, T suffixes)
        let marketCap = 0;
        if (marketCapEl) {
          const capText = marketCapEl.textContent.trim();
          if (capText === 'N/A' || capText === '-' || capText === '') {
            marketCap = 0; // Treat N/A and empty values as 0 for sorting
          } else {
            const cleanText = capText.replace(/[^0-9.KMBT]/g, '');
            const capNum = parseFloat(cleanText) || 0;
            if (cleanText.includes('T')) marketCap = capNum * 1e12;
            else if (cleanText.includes('B')) marketCap = capNum * 1e9;
            else if (cleanText.includes('M')) marketCap = capNum * 1e6;
            else if (cleanText.includes('K')) marketCap = capNum * 1e3;
            else marketCap = capNum;
          }
        }
        
        // Parse price change percentage
        let priceChange = 0;
        if (pricePctEl) {
          const pctText = pricePctEl.textContent.replace(/[^0-9.\-+]/g, '');
          priceChange = parseFloat(pctText) || 0;
        }
        
        stocksData.push({
          symbol,
          price,
          priceChange,
          volume,
          marketCap,
          rsi,
          ma50,
          ma200,
          atr,
          smartScore
        });
      });
      
      // Sort the data
      stocksData.sort((a, b) => {
        let aVal = a[tableSortColumn] || 0;
        let bVal = b[tableSortColumn] || 0;
        
        // Handle string sorting for symbol
        if (tableSortColumn === 'symbol') {
          aVal = a.symbol;
          bVal = b.symbol;
          return tableSortDirection === 'asc' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
        }
        
        // For price column, sort by priceChange (percentage change) instead of absolute price
        if (tableSortColumn === 'price') {
          aVal = a.priceChange || 0;
          bVal = b.priceChange || 0;
        }
        
        // Numeric sorting
        if (tableSortDirection === 'asc') {
          return aVal - bVal;
        } else {
          return bVal - aVal;
        }
      });
      
      return stocksData.map(item => item.symbol);
    }
    
    // Re-sort table rows after data update
    function resortTableRows() {
      const tableBody = document.getElementById('tableBody');
      if (!tableBody) return;
      
      const sortedSymbols = getSortableStocksData();
      const rows = Array.from(tableBody.querySelectorAll('tr'));
      
      // Clear table body
      tableBody.innerHTML = '';
      
      // Add rows in sorted order (both main row and detail row for each symbol)
      sortedSymbols.forEach(symbol => {
        const mainRow = rows.find(r => r.getAttribute('data-symbol') === symbol);
        const detailRow = rows.find(r => r.id === `${symbol}-details`);
        
        if (mainRow) {
          tableBody.appendChild(mainRow);
        }
        if (detailRow) {
          tableBody.appendChild(detailRow);
        }
      });
    }
    
    // Update table headers with sort indicators
    function updateTableHeaders() {
      const headers = {
        'symbol': document.querySelector('th[onclick*="sortTable(\'symbol\')"]'),
        'price': document.querySelector('th[onclick*="sortTable(\'price\')"]'),
        'marketCap': document.querySelector('th[onclick*="sortTable(\'marketCap\')"]'),
        'priceChange': document.querySelector('th[onclick*="sortTable(\'priceChange\')"]'),
        'volume': document.querySelector('th[onclick*="sortTable(\'volume\')"]'),
        'rsi': document.querySelector('th[onclick*="sortTable(\'rsi\')"]'),
        'ma50': document.querySelector('th[onclick*="sortTable(\'ma50\')"]'),
        'ma200': document.querySelector('th[onclick*="sortTable(\'ma200\')"]'),
        'atr': document.querySelector('th[onclick*="sortTable(\'atr\')"]'),
        'smartScore': document.querySelector('th[onclick*="sortTable(\'smartScore\')"]')
      };
      
      Object.keys(headers).forEach(column => {
        const header = headers[column];
        if (header) {
          const baseText = header.textContent.replace(/\s*[▲▼]\s*$/, ''); // Remove existing arrows
          const sortIndicator = tableSortColumn === column ? (tableSortDirection === 'asc' ? ' ▲' : ' ▼') : '';
          header.textContent = baseText + sortIndicator;
        }
      });
    }
    
    // Toggle stock details expansion
    function toggleStockDetails(symbol) {
      const detailsRow = document.getElementById(`${symbol}-details`);
      const expandIcon = document.getElementById(`${symbol}-expand-icon`);
      
      if (!detailsRow || !expandIcon) return;
      
      const isExpanded = detailsRow.style.display !== 'none';
      
      if (isExpanded) {
        // Collapse
        detailsRow.style.display = 'none';
        expandIcon.style.transform = 'rotate(0deg)';
        expandIcon.className = 'bi bi-chevron-right expand-icon me-3';
      } else {
        // Expand
        detailsRow.style.display = '';
        expandIcon.style.transform = 'rotate(90deg)';
        expandIcon.className = 'bi bi-chevron-down expand-icon me-3';
      }
    }
    
    // Make function available globally
    window.toggleStockDetails = toggleStockDetails;
    
    // Helper function to parse market cap strings like "1.23B", "456.78M", etc.
    function parseMarketCapString(mcStr) {
      if (!mcStr || typeof mcStr !== 'string') return null;
      
      const cleanStr = mcStr.replace(/[,$]/g, '').trim();
      const numPart = parseFloat(cleanStr);
      
      if (isNaN(numPart)) return null;
      
      const lastChar = cleanStr.slice(-1).toUpperCase();
      
      switch (lastChar) {
        case 'T': return numPart * 1e12;
        case 'B': return numPart * 1e9;
        case 'M': return numPart * 1e6;
        case 'K': return numPart * 1e3;
        default: return numPart;
      }
    }

    // Dedicated function to fetch market cap data from multiple sources
    async function fetchMarketCap(symbol, metaData = null, currentPrice = null) {
      let marketCap = null;
      
      try {
        console.log(`[${symbol}] Extracting market cap from multiple sources...`);
        
        // Method 1: Try to get market cap from Yahoo meta data first
        if (metaData && metaData.marketCap) {
          marketCap = metaData.marketCap;
          console.log(`[${symbol}] Found market cap in meta.marketCap:`, marketCap);
          return marketCap;
        } else if (metaData && metaData.sharesOutstanding && currentPrice) {
          // Calculate market cap: shares outstanding * current price
          marketCap = metaData.sharesOutstanding * currentPrice;
          console.log(`[${symbol}] Calculated market cap from shares outstanding (${metaData.sharesOutstanding}) * price (${currentPrice}):`, marketCap);
          return marketCap;
        }
        
        console.log(`[${symbol}] No market cap in meta data, trying alternative sources...`);
        
        // Method 2: Try Yahoo Finance quote API (different endpoint)
        try {
          const quoteUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://query1.finance.yahoo.com/v7/finance/quote?symbols=${symbol}`)}`;
          console.log(`[${symbol}] Trying quote API...`);
          
          const quoteRes = await fetch(quoteUrl);
          if (quoteRes.ok) {
            const quoteWrapper = await quoteRes.json();
            if (quoteWrapper.contents) {
              const quoteData = JSON.parse(quoteWrapper.contents);
              
              if (quoteData.quoteResponse && quoteData.quoteResponse.result && quoteData.quoteResponse.result[0]) {
                const quote = quoteData.quoteResponse.result[0];
                if (quote.marketCap) {
                  marketCap = quote.marketCap;
                  console.log(`[${symbol}] Found market cap in quote API:`, marketCap);
                  return marketCap;
                } else if (quote.sharesOutstanding && currentPrice) {
                  marketCap = quote.sharesOutstanding * currentPrice;
                  console.log(`[${symbol}] Calculated market cap from quote API:`, marketCap);
                  return marketCap;
                }
              }
            }
          }
        } catch (quoteError) {
          console.log(`[${symbol}] Quote API failed:`, quoteError.message);
        }
        
        // Method 3: Try FMP (Financial Modeling Prep) market-capitalization endpoint
        if (!marketCap) {
          console.log(`[${symbol}] Attempting market cap from FMP API...`);
          
          try {
            const fmpUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://financialmodelingprep.com/api/v3/market-capitalization/${symbol}?apikey=YXzEgLXuiXGOswPD4DSYXgY5ykU1gNfe`)}`;
            const fmpRes = await fetch(fmpUrl);
            if (fmpRes.ok) {
              const fmpWrapper = await fmpRes.json();
              if (fmpWrapper.contents) {
                const fmpData = JSON.parse(fmpWrapper.contents);
                console.log(`[${symbol}] FMP market-cap API response:`, fmpData);
                if (fmpData && fmpData.length > 0 && fmpData[0].marketCap) {
                  marketCap = fmpData[0].marketCap;
                  console.log(`[${symbol}] Found market cap from FMP:`, marketCap);
                  return marketCap;
                }
              }
            }
          } catch (fmpError) {
            console.log(`[${symbol}] FMP market-cap API failed:`, fmpError.message);
          }
        }
        
        // Method 4: Try FMP company profile endpoint (often has market cap as mktCap)
        if (!marketCap) {
          try {
            const profileUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://financialmodelingprep.com/api/v3/profile/${symbol}?apikey=YXzEgLXuiXGOswPD4DSYXgY5ykU1gNfe`)}`;
            const profileRes = await fetch(profileUrl);
            if (profileRes.ok) {
              const profileWrapper = await profileRes.json();
              if (profileWrapper.contents) {
                const profileData = JSON.parse(profileWrapper.contents);
                console.log(`[${symbol}] FMP Profile API response:`, profileData);
                if (profileData && profileData.length > 0 && profileData[0].mktCap) {
                  marketCap = profileData[0].mktCap;
                  console.log(`[${symbol}] Found market cap from FMP profile:`, marketCap);
                  return marketCap;
                }
              }
            }
          } catch (profileError) {
            console.log(`[${symbol}] FMP Profile API failed:`, profileError.message);
          }
        }
        
      } catch (e) {
        console.log(`Market cap extraction failed for ${symbol}:`, e.message);
      }
      
      // Handle special cases and fallbacks
      if (!marketCap) {
        // ETFs don't have market cap - set to null explicitly
        const etfsWithoutMarketCap = {
          'SPY': true, 'QQQ': true, 'IWM': true, 'VTI': true, 'VUG': true, 'VTV': true,
          'VEA': true, 'VWO': true, 'BND': true, 'AGG': true, 'GLD': true, 'SLV': true,
          'XLF': true, 'XLK': true, 'XLE': true, 'XLV': true, 'XLI': true, 'XLU': true,
          'XLP': true, 'XLY': true, 'XLB': true, 'XLRE': true, 'XLC': true
        };
        
        if (etfsWithoutMarketCap[symbol]) {
          console.log(`[${symbol}] ETF detected - market cap set to null`);
          return null; // ETFs don't have market cap
        } else {
          // For stocks without real market cap data, set to undefined to show "N/A"
          console.log(`[${symbol}] No market cap data available - set to undefined`);
          return undefined;
        }
      }
      
      return marketCap;
    }

    // Fetch stock data with smart caching
    async function fetchStockData(symbol, retry = true) {
      try {
        // Check if we have cached historical data
        const historicalKey = `historical_${symbol}`;
        const historicalTimestampKey = `historical_${symbol}_timestamp`;
        const cachedHistorical = localStorage.getItem(historicalKey);
        const cachedTimestamp = localStorage.getItem(historicalTimestampKey);
        
        const now = Date.now();
        const isHistoricalCacheValid = cachedTimestamp && (now - parseInt(cachedTimestamp)) < HISTORICAL_CACHE_DURATION;
        
        let historicalData = null;
        let useQuickUpdate = false;
        
        if (isHistoricalCacheValid && cachedHistorical) {
          // Use cached historical data and fetch only recent data
          historicalData = JSON.parse(cachedHistorical);
          useQuickUpdate = true;
          console.log(`Using cached historical data for ${symbol}, fetching recent updates only`);
        }
        
        // Determine the range to fetch
        let rangeParam = '200d'; // Full range for initial load
        if (useQuickUpdate) {
          rangeParam = '5d'; // Only last 5 days for quick updates
        }
        
        const ts = Date.now();
        const url = `https://api.allorigins.win/get?url=${encodeURIComponent('https://query1.finance.yahoo.com/v8/finance/chart/' + symbol + '?interval=1d&range=' + rangeParam + '&_=' + ts)}`;
        
        console.log(`Fetching data for ${symbol} with range ${rangeParam}`);
        const res = await fetch(url);
        if (!res.ok) {
          console.error(`HTTP error for ${symbol}: ${res.status} ${res.statusText}`);
          throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        }
        const wrapper = await res.json();
        if (!wrapper.contents) {
          console.error(`No contents in API response for ${symbol}:`, wrapper);
          throw new Error('No contents in API response');
        }
        const data = JSON.parse(wrapper.contents);
        if (!data.chart || !data.chart.result || !data.chart.result[0]) {
          console.error(`Invalid chart data for ${symbol}:`, data);
          throw new Error('Invalid chart data from Yahoo Finance');
        }
        const result = data.chart.result[0];
        
        // Extract company name and other metadata from the API response
        let companyName = null;
        let longName = null;
        if (result.meta) {
          longName = result.meta.longName || result.meta.shortName || null;
          companyName = longName; // Use longName as companyName for consistency
        }
        
        let closes, volumes, highs, lows, timestamps;
        
        if (useQuickUpdate && historicalData) {
          // Merge recent data with cached historical data
          const recentTimestamps = result.timestamp;
          const recentCloses = result.indicators.quote[0].close;
          const recentVolumes = result.indicators.quote[0].volume;
          const recentHighs = result.indicators.quote[0].high;
          const recentLows = result.indicators.quote[0].low;
          
          // Find where to merge (avoid duplicates)
          const lastHistoricalTimestamp = historicalData.timestamps[historicalData.timestamps.length - 1];
          const mergeIndex = recentTimestamps.findIndex(ts => ts > lastHistoricalTimestamp);
          
          if (mergeIndex > -1) {
            // Merge new data
            timestamps = [...historicalData.timestamps, ...recentTimestamps.slice(mergeIndex)];
            closes = [...historicalData.closes, ...recentCloses.slice(mergeIndex)];
            volumes = [...historicalData.volumes, ...recentVolumes.slice(mergeIndex)];
            highs = [...historicalData.highs, ...recentHighs.slice(mergeIndex)];
            lows = [...historicalData.lows, ...recentLows.slice(mergeIndex)];
            
            // Keep only last 200 data points to prevent unlimited growth
            if (timestamps.length > 200) {
              const keepFrom = timestamps.length - 200;
              timestamps = timestamps.slice(keepFrom);
              closes = closes.slice(keepFrom);
              volumes = volumes.slice(keepFrom);
              highs = highs.slice(keepFrom);
              lows = lows.slice(keepFrom);
            }
          } else {
            // Use existing data if no new data
            timestamps = historicalData.timestamps;
            closes = historicalData.closes;
            volumes = historicalData.volumes;
            highs = historicalData.highs;
            lows = historicalData.lows;
          }
        } else {
          // Use fresh data from API
          timestamps = result.timestamp;
          closes = result.indicators.quote[0].close;
          volumes = result.indicators.quote[0].volume;
          highs = result.indicators.quote[0].high;
          lows = result.indicators.quote[0].low;
        }
        
        // Calculate basic values first
        const lastIdx = closes.length - 1;
        const price = closes[lastIdx];
        const volume = volumes[lastIdx];
        
        // Fetch market cap data if not in historical cache or if cache is old
        let marketCap = null;
        if (historicalData && historicalData.marketCap !== undefined) {
          // Use cached market cap
          marketCap = historicalData.marketCap;
          console.log(`[${symbol}] Using cached market cap:`, marketCap);
        } else {
          // Fetch market cap from multiple sources
          console.log(`[${symbol}] Fetching fresh market cap data...`);
          marketCap = await fetchMarketCap(symbol, result.meta, price);
        }
        
        // Save/update historical cache with market cap included
        const newHistoricalData = { 
          timestamps, 
          closes, 
          volumes, 
          highs, 
          lows, 
          marketCap,
          companyName: longName 
        };
        localStorage.setItem(historicalKey, JSON.stringify(newHistoricalData));
        localStorage.setItem(historicalTimestampKey, now.toString());
        
        // Find previous trading day (not just previous data point)
        // Look for the most recent close that's from a different day
        let prevDayClose = null;
        let prevDayVolume = null;
        
        if (timestamps.length >= 2) {
          const currentDayTimestamp = timestamps[lastIdx];
          const currentDay = new Date(currentDayTimestamp * 1000).toDateString();
          
          // Search backwards for the last close from a different day
          for (let i = lastIdx - 1; i >= 0; i--) {
            const checkDay = new Date(timestamps[i] * 1000).toDateString();
            if (checkDay !== currentDay && closes[i] !== null) {
              prevDayClose = closes[i];
              prevDayVolume = volumes[i];
              break;
            }
          }
          
          // If we can't find a different day, fall back to previous data point
          if (prevDayClose === null && lastIdx > 0) {
            prevDayClose = closes[lastIdx - 1];
            prevDayVolume = volumes[lastIdx - 1];
          }
        }
        
        // Today's high/low
        let todayHigh = highs ? highs[lastIdx] : null;
        let todayLow = lows ? lows[lastIdx] : null;
        // 50-day average volume
        let avgVol50 = null, avgVol50Pct = null;
        if (volumes.length >= 50) {
          const arr = volumes.slice(-50).filter(v => v !== null);
          avgVol50 = arr.reduce((a,b) => a+b, 0) / arr.length;
          if (avgVol50 && avgVol50 !== 0) {
            avgVol50Pct = ((volume - avgVol50) / avgVol50) * 100;
          }
        }
        // Sparkline data (last 20 closes)
        let sparkData = closes.slice(-20);
        // RSI (14) - Proper Wilder's smoothing method matching TradingView
        let rsi = null, rsiDir = 'neutral', previousRSI = null;
        if (closes.length >= 15) {
          // Calculate RSI using full history and Wilder's smoothing
          function calculateRSI(prices, endIndex, period = 14) {
            if (endIndex < period) return null;
            let gains = [], losses = [];
            for (let i = 1; i <= endIndex; i++) {
              const change = prices[i] - prices[i - 1];
              gains.push(change > 0 ? change : 0);
              losses.push(change < 0 ? -change : 0);
            }
            // Initial average gain/loss for first period
            let avgGain = 0, avgLoss = 0;
            for (let i = 0; i < period; i++) {
              avgGain += gains[i];
              avgLoss += losses[i];
            }
            avgGain /= period;
            avgLoss /= period;
            // Wilder's smoothing for subsequent periods
            for (let i = period; i < gains.length; i++) {
              avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
              avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
            }
            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
          }
          // Calculate current RSI
          rsi = calculateRSI(closes, lastIdx);
          // Calculate previous day RSI for trend comparison
          if (lastIdx >= 15) {
            previousRSI = calculateRSI(closes, lastIdx - 1);
          }
          
          rsiDir = closes[lastIdx] > closes[lastIdx-1] ? 'up' : (closes[lastIdx] < closes[lastIdx-1] ? 'down' : 'neutral');
        }
        // CCI(14)
        let cci = null, cciDir = 'neutral', cciDays = '', previousCCI = null;
        if (closes.length > 15 && highs && lows) {
          // Calculate current CCI (using last 14 periods)
          let tpArr = [];
          for (let i = closes.length - 14; i < closes.length; i++) {
            const high = highs[i];
            const low = lows[i];
            const close = closes[i];
            if (high == null || low == null || close == null) continue;
            tpArr.push((high + low + close) / 3);
          }
          if (tpArr.length === 14) {
            const tp = tpArr[tpArr.length-1];
            const tpMean = tpArr.reduce((a,b) => a+b, 0) / 14;
            const meanDev = tpArr.reduce((a,b) => a + Math.abs(b - tpMean), 0) / 14;
            if (meanDev !== 0) {
              cci = (tp - tpMean) / (0.015 * meanDev);
            }
          }
          
          // Calculate previous day CCI (using 14 periods ending one day before)
          if (closes.length > 16) {
            let prevTpArr = [];
            for (let i = closes.length - 15; i < closes.length - 1; i++) {
              const high = highs[i];
              const low = lows[i];
              const close = closes[i];
              if (high == null || low == null || close == null) continue;
              prevTpArr.push((high + low + close) / 3);
            }
            if (prevTpArr.length === 14) {
              const prevTp = prevTpArr[prevTpArr.length-1];
              const prevTpMean = prevTpArr.reduce((a,b) => a+b, 0) / 14;
              const prevMeanDev = prevTpArr.reduce((a,b) => a + Math.abs(b - prevTpMean), 0) / 14;
              if (prevMeanDev !== 0) {
                previousCCI = (prevTp - prevTpMean) / (0.015 * prevMeanDev);
              }
            }
          }
          
          if (tpArr.length === 14) {
            if (tpArr[13] > tpArr[12]) cciDir = 'up';
            else if (tpArr[13] < tpArr[12]) cciDir = 'down';
            else cciDir = 'neutral';
            let up = 0, down = 0;
            for (let i = 10; i < 13; i++) {
              if (tpArr[i+1] > tpArr[i]) up++;
              else if (tpArr[i+1] < tpArr[i]) down++;
            }
            cciDays = `${up}-${down} 2-4 Days ${up>down?'Up':'Down'}`;
          }
        }
        // 50MA
        let ma50 = null, ma50Dir = 'neutral';
        if (closes.length >= 51) {
          const maArr = closes.slice(-50).filter(c => c !== null);
          ma50 = maArr.reduce((a,b) => a+b, 0) / maArr.length;
          ma50Dir = price > ma50 ? 'up' : (price < ma50 ? 'down' : 'neutral');
        }
        // 150MA
        let ma150 = null, maDir = 'neutral';
        if (closes.length >= 151) {
          const maArr = closes.slice(-150).filter(c => c !== null);
          ma150 = maArr.reduce((a,b) => a+b, 0) / maArr.length;
          maDir = price > ma150 ? 'up' : (price < ma150 ? 'down' : 'neutral');
        }
        // 200MA
        let ma200 = null, ma200Dir = 'neutral';
        if (closes.length >= 200) {
          const maArr = closes.slice(-200).filter(c => c !== null);
          ma200 = maArr.reduce((a,b) => a+b, 0) / maArr.length;
          ma200Dir = price > ma200 ? 'up' : (price < ma200 ? 'down' : 'neutral');
        }
        // Volume direction (compared to previous day)
        let volDir = 'neutral';
        let volPct = null;
        if (prevDayVolume !== null && volume !== null) {
          if (volume > prevDayVolume) volDir = 'up';
          else if (volume < prevDayVolume) volDir = 'down';
          if (prevDayVolume && prevDayVolume !== 0) {
            volPct = ((volume - prevDayVolume) / prevDayVolume) * 100;
          }
        }
        
        // Price direction (compared to previous day's close)
        let priceDir = 'neutral';
        let pricePct = null;
        if (prevDayClose !== null && price !== null) {
          if (price > prevDayClose) priceDir = 'up';
          else if (price < prevDayClose) priceDir = 'down';
          if (prevDayClose && prevDayClose !== 0) {
            pricePct = ((price - prevDayClose) / prevDayClose) * 100;
          }
        }
        // ATR(14)
        let atr14 = null, atr14Ind = 'ok';
        if (closes.length > 15 && highs && lows) {
          let trs = [];
          for (let i = closes.length - 14; i < closes.length; i++) {
            const high = highs[i];
            const low = lows[i];
            const prevClose = closes[i-1];
            if (high == null || low == null || prevClose == null) continue;
            const tr = Math.max(
              high - low,
              Math.abs(high - prevClose),
              Math.abs(low - prevClose)
            );
            trs.push(tr);
          }
          if (trs.length === 14) {
            atr14 = trs.reduce((a,b) => a+b, 0) / 14;
            // No longer using directional ATR indicators - using color coding instead
            atr14Ind = 'neutral';
          }
        }
        // Earnings date (Yahoo Finance profile API)
        let earningsDays = null;
        try {
          // Skip earnings for now to reduce API calls
        } catch (e) {}
        
        // --- Advanced Technical Indicators for Smart Score ---
        
        // Calculate Bollinger Bands
        let bollingerBands = null, bollingerSignal = null;
        bollingerBands = calculateBollingerBands(closes);
        if (bollingerBands && price) {
          bollingerSignal = getBollingerSignal(price, bollingerBands);
        }
        
        // Calculate MACD
        let macdData = null, macdSignal = null, previousMACDData = null;
        macdData = calculateMACD(closes);
        
        // Get previous MACD for crossover detection (using closes minus last value)
        if (closes.length > 35) {
          const previousCloses = closes.slice(0, -1);
          previousMACDData = calculateMACD(previousCloses);
        }
        
        if (macdData) {
          macdSignal = getMACDSignal(macdData, previousMACDData);
        }
        
        // Calculate Smart Score
        let smartScore = null;
        const signals = [];
        
        // Bollinger Bands signals
        if (bollingerSignal && bollingerSignal.signal !== 'neutral') {
          signals.push({ ...bollingerSignal, indicator: 'Bollinger Bands' });
        }
        
        // MACD signals
        if (macdSignal && macdSignal.signal !== 'neutral') {
          signals.push({ ...macdSignal, indicator: 'MACD' });
        }
        
        // RSI signals
        if (rsi) {
          const rsiSignal = getRSISignal(rsi, previousRSI);
          if (rsiSignal && rsiSignal.signal !== 'neutral') {
            signals.push({ ...rsiSignal, indicator: 'RSI' });
          }
        }
        
        // Volume confirmation signals
        if (volume && avgVol50 && priceDir && volDir) {
          const volumeSignal = getVolumeSignal(volume, avgVol50, priceDir, volDir);
          if (volumeSignal && volumeSignal.signal !== 'neutral') {
            signals.push({ ...volumeSignal, indicator: 'Volume' });
          }
        }
        
        // Trend confirmation signals
        if (price && ma50 && ma150 && ma200) {
          const trendSignal = getTrendSignal(price, ma50, ma150, ma200);
          if (trendSignal && trendSignal.signal !== 'neutral') {
            signals.push({ ...trendSignal, indicator: 'Trend' });
          }
        }
        
        // Calculate final Smart Score
        if (signals.length > 0) {
          smartScore = calculateSmartScore(signals);
          
          // Check for Smart Score alerts (only if enabled)
          if (smartAlertsEnabled) {
            checkSmartScoreAlerts(symbol, smartScore);
          }
        } else {
          smartScore = { score: 50, sentiment: 'neutral', confidence: 'low', signals: [], totalSignals: 0 };
        }
        
        // --- Calculate Target Price and Support Level ---
        let targetPrice = null, supportLevel = null;
        if (closes.length >= 50 && highs && lows) {
          // Calculate resistance level (target price) using 50-day high
          const recent50Highs = highs.slice(-50);
          const recent50Lows = lows.slice(-50);
          const highest50 = Math.max(...recent50Highs);
          const lowest50 = Math.min(...recent50Lows);
          
          // Target price: Next resistance level above current price
          // Use recent significant highs as resistance
          const significantHighs = [];
          for (let i = recent50Highs.length - 20; i < recent50Highs.length; i++) {
            if (i > 0 && i < recent50Highs.length - 1) {
              const current = recent50Highs[i];
              const prev = recent50Highs[i - 1];
              const next = recent50Highs[i + 1];
              if (current > prev && current > next && current > price) {
                significantHighs.push(current);
              }
            }
          }
          
          if (significantHighs.length > 0) {
            targetPrice = Math.min(...significantHighs); // Nearest resistance above current price
          } else if (highest50 > price) {
            targetPrice = highest50; // Fallback to 50-day high
          }
          
          // Support level: Recent significant lows below current price
          const significantLows = [];
          for (let i = recent50Lows.length - 20; i < recent50Lows.length; i++) {
            if (i > 0 && i < recent50Lows.length - 1) {
              const current = recent50Lows[i];
              const prev = recent50Lows[i - 1];
              const next = recent50Lows[i + 1];
              if (current < prev && current < next && current < price) {
                significantLows.push(current);
              }
            }
          }
          
          if (significantLows.length > 0) {
            supportLevel = Math.max(...significantLows); // Nearest support below current price
          } else if (lowest50 < price) {
            supportLevel = lowest50; // Fallback to 50-day low
          }
        }
        
        // --- Calculate Volume Strength Indicator ---
        let volumeStrength = null, volumeTrend = null;
        if (volume && avgVol50 && volumes.length >= 10) {
          // Volume strength: Current volume vs 50-day average
          const volRatio = volume / avgVol50;
          
          if (volRatio >= 2.0) {
            volumeStrength = 'Very High';
          } else if (volRatio >= 1.5) {
            volumeStrength = 'High';
          } else if (volRatio >= 1.2) {
            volumeStrength = 'Above Avg';
          } else if (volRatio >= 0.8) {
            volumeStrength = 'Normal';
          } else if (volRatio >= 0.5) {
            volumeStrength = 'Low';
          } else {
            volumeStrength = 'Very Low';
          }
          
          // Volume trend: Compare recent volume trend
          const recent10Volumes = volumes.slice(-10);
          const firstHalf = recent10Volumes.slice(0, 5);
          const secondHalf = recent10Volumes.slice(5);
          const firstAvg = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;
          const secondAvg = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;
          
          if (secondAvg > firstAvg * 1.2) {
            volumeTrend = 'Increasing';
          } else if (secondAvg < firstAvg * 0.8) {
            volumeTrend = 'Decreasing';
          } else {
            volumeTrend = 'Stable';
          }
        }
        
        return {
          price, prevDayClose, priceDir, pricePct,
          volume, prevDayVolume, volDir, volPct,
          rsi, rsiDir, previousRSI,
          cci, cciDir, cciDays, previousCCI,
          ma50, ma50Dir,
          ma150, maDir,
          ma200, ma200Dir,
          todayHigh, todayLow,
          avgVol50, avgVol50Pct,
          sparkData,
          atr14, atr14Ind,
          earningsDays,
          marketCap,
          // Company information
          companyName,
          longName,
          // Advanced indicators
          bollingerBands,
          bollingerSignal,
          macdData,
          macdSignal,
          smartScore,
          // New indicators
          targetPrice,
          supportLevel,
          volumeStrength,
          volumeTrend,
          lastUpdated: Date.now()
        };
      } catch (e) {
        console.error(`Error in fetchStockData for ${symbol}:`, e);
        if (retry) {
          console.log(`Retrying fetchStockData for ${symbol} in 2 seconds...`);
          await new Promise(res => setTimeout(res, 2000));
          return fetchStockData(symbol, false);
        }
        console.error(`Failed to fetch data for ${symbol} after retry`);
        return null;
      }
    }

    // Render stocks
    async function renderStocks(skipDataUpdate = false) {
      // If in indexes mode, render indexes instead
      if (currentViewMode === 'indexes') {
        await renderIndexes();
        return;
      }
      
      stockList.innerHTML = '';
      let stocks = getTrackedStocks();
      // Filter
      const filter = filterInput.value.trim().toUpperCase();
      if (filter) stocks = stocks.filter(s => {
        const symbol = typeof s === 'object' ? s.symbol : s;
        return symbol.includes(filter);
      });
      if (stocks.length === 0) {
        stockList.innerHTML = '<div class="loading">No stocks tracked. Add one above or adjust filter.</div>';
        return;
      }
      loading.style.display = 'block';
      
      if (isTableView) {
        // For table view, render only main value columns (no direction/CCI days)
        // Add style for smaller fonts in table view
        if (!document.getElementById('tableFontSizeStyle')) {
          const style = document.createElement('style');
          style.id = 'tableFontSizeStyle';
          style.innerHTML = `
            .stock-table-sm, .stock-table-sm th, .stock-table-sm td {
              font-size: 0.85rem !important;
              padding: 0.25rem 0.4rem !important;
            }
            .stock-table-sm th, .stock-table-sm td {
              vertical-align: middle !important;
            }
          `;
          document.head.appendChild(style);
        }
        let tableHtml = `
          <div class="col-12">
            <div class="card shadow-sm">
              <div class="card-body p-0">
                <div class="table-responsive">
                  <table class="table table-hover mb-0 stock-table-sm stock-table-mobile">
                    <thead class="table-light">
                      <tr>
                        <th class="sortable" onclick="sortTable('symbol')" style="cursor: pointer; min-width: 120px;">Symbol</th>
                        <th style="min-width: 60px; text-align: center;"></th>
                        <th class="sortable" onclick="sortTable('price')" style="cursor: pointer; min-width: 120px;">Price (% Change)</th>
                        <th>Volume</th>
                        <th>RSI(14)</th>
                        <th class="sortable" onclick="sortTable('atr')" style="cursor: pointer; min-width: 80px;">ATR(14)</th>
                        <th class="sortable" onclick="sortTable('marketCap')" style="cursor: pointer; min-width: 100px;">Market Cap</th>
                        <th class="sortable" style="min-width: 100px; text-align: center; cursor: pointer;" onclick="sortTable('smartScore')">Smart Score</th>
                        <th>Last update</th>
                        <th style="min-width: 80px;">Actions</th>
                      </tr>
                    </thead>
                    <tbody id="tableBody">`;
        stocks.forEach(stock => {
          const symbol = typeof stock === 'object' ? stock.symbol : stock;
          const data = currentDataCache[symbol] || {};
          const hasAlert = getAlerts(symbol).length > 0;
          const alertCount = getAlerts(symbol).length;
          
          // Determine border color based on price trend
          let borderColor = '#6c757d'; // neutral gray
          if (data.priceDir === 'up') {
            borderColor = '#28a745'; // green for up
          } else if (data.priceDir === 'down') {
            borderColor = '#dc3545'; // red for down
          }
          
          tableHtml += `
            <tr data-symbol="${symbol}" style="border-left: 3px solid ${borderColor}; cursor: pointer;" onclick="toggleStockDetails('${symbol}')">
              <td>
                <div class="d-flex align-items-center">
                  <i class="bi bi-chevron-right expand-icon me-3" id="${symbol}-expand-icon" style="transition: transform 0.2s; font-size: 0.9rem; color: #6c757d;"></i>
                  <div>
                    <strong class="stock-symbol">${symbol}</strong>
                    <div style="font-size: 0.7rem; color: #6c757d; line-height: 1.1;" id="${symbol}-companyName">
                      <span id="${symbol}-companyNameText" style="max-width:160px; display:inline-block; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; vertical-align:middle;" title="${data.companyName || ''}"></span>
                    </div>
                  </div>
                </div>
              </td>
              <td style="text-align: center;">
                <div class="d-flex justify-content-center gap-1">
                  <i class="bi bi-bell alert-indicator${hasAlert ? ' active' : ''}" id="${symbol}-alertBell-table" title="${hasAlert ? `View ${alertCount} alert${alertCount > 1 ? 's' : ''}` : 'Add alert'}" onclick="event.stopPropagation(); showAlertsModal('${symbol}')"></i>
                  <i class="notes-icon ${hasNotes(symbol) ? 'bi-sticky-fill has-notes' : 'bi-sticky'}" id="${symbol}-notesIcon-table" title="${hasNotes(symbol) ? 'Edit notes' : 'Add notes'}" onclick="event.stopPropagation(); showNotesModal('${symbol}')"></i>
                </div>
              </td>
              <td><span id="${symbol}-price">-</span> <span id="${symbol}-pricePct" class="neutral"></span> <span id="${symbol}-spark" style="margin-left:8px; vertical-align:middle;"></span></td>
              <td><span id="${symbol}-volume">-</span> <span id="${symbol}-volPct" class="neutral"></span></td>
              <td>
                <span id="${symbol}-rsi">-</span>
                <span id="${symbol}-rsiTrend" class="neutral" title="RSI trend"></span>
              </td>
              <td>
                <span id="${symbol}-atr14">-</span>
                <span id="${symbol}-atr14Pct" class="neutral"></span>
                <span id="${symbol}-atr14Ind" class="neutral" title="ATR volatility indicator"></span>
              </td>
              <td><span id="${symbol}-marketCap">-</span></td>
              <td style="text-align: center;">
                <div id="${symbol}-smartScore" class="smart-score-container">
                  <div class="smart-score-value" id="${symbol}-smartScoreValue">-</div>
                  <div class="smart-score-sentiment" id="${symbol}-smartScoreSentiment">-</div>
                </div>
              </td>
              <td><span id="${symbol}-updated" class="neutral">-</span></td>
              <td onclick="event.stopPropagation();">
                <div class="dropdown">
                  <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                    <i class="bi bi-three-dots"></i>
                  </button>
                  <ul class="dropdown-menu dropdown-menu-end">
                    ${generateStockDropdownMenu(symbol)}
                  </ul>
                </div>
              </td>
            </tr>
            <tr id="${symbol}-details" class="stock-details-row" style="display: none;">
              <td colspan="10" style="background-color: #f8f9fa; padding: 0;border-left: 3px solid ${borderColor};">
                <div class="p-3">
                  <div class="row">
                    <div class="col-md-6 col-lg-3 mb-3">
                      <h6 class="text-muted mb-2">Price Analysis</h6>
                      <div class="mb-1"><small class="text-muted">High/Low:</small> <span id="${symbol}-highlow">-</span></div>
                      <div class="mb-1"><small class="text-muted">ATR(14):</small> <span id="${symbol}-atr14-details">-</span> <span id="${symbol}-atr14Pct-details" class="neutral"></span> <span id="${symbol}-atr14Ind-details" class="neutral"></span></div>
                      <div class="mb-1"><small class="text-muted">Stop Loss:</small> <span id="${symbol}-stoploss">-</span></div>
                      <div class="mb-1"><small class="text-muted">Target Price:</small> <span id="${symbol}-targetprice" class="neutral">-</span></div>
                      <div><small class="text-muted">Support Level:</small> <span id="${symbol}-support" class="neutral">-</span></div>
                    </div>
                    <div class="col-md-6 col-lg-3 mb-3">
                      <h6 class="text-muted mb-2">Volume Analysis</h6>
                      <div class="mb-1"><small class="text-muted">50d Avg Vol:</small> <span id="${symbol}-avgvol-table" class="neutral">-</span></div>
                      <div class="mb-1"><small class="text-muted">Volume Strength:</small> <span id="${symbol}-volstrength" class="neutral">-</span></div>
                      <div><small class="text-muted">Volume Trend:</small> <span id="${symbol}-voltrend" class="neutral">-</span></div>
                    </div>
                    <div class="col-md-6 col-lg-3 mb-3">
                      <h6 class="text-muted mb-2">Technical Indicators</h6>
                      <div class="mb-1"><small class="text-muted">CCI(14):</small> <span id="${symbol}-cci">-</span> <span id="${symbol}-cciTrend" class="neutral"></span></div>
                      <div class="mb-1"><small class="text-muted">50MA:</small> <span id="${symbol}-ma50">-</span> <span id="${symbol}-ma50Trend" class="neutral"></span></div>
                      <div class="mb-1"><small class="text-muted">150MA:</small> <span id="${symbol}-ma150">-</span> <span id="${symbol}-ma150Trend" class="neutral"></span></div>
                      <div><small class="text-muted">200MA:</small> <span id="${symbol}-ma200">-</span> <span id="${symbol}-ma200Trend" class="neutral"></span></div>
                    </div>
                    <div class="col-md-6 col-lg-3 mb-3">
                      <h6 class="text-muted mb-2">Quick Actions</h6>
                      <div class="d-flex gap-2 flex-wrap">
                        <a href="https://finance.yahoo.com/quote/${symbol}" target="_blank" rel="noopener" class="btn btn-sm btn-outline-primary">
                          <i class="bi bi-info-circle"></i> Yahoo
                        </a>
                        <a href="https://www.tradingview.com/symbols/${symbol}/" target="_blank" rel="noopener" class="btn btn-sm btn-outline-success">
                          <i class="bi bi-graph-up"></i> TradingView
                        </a>
                      </div>
                    </div>
                  </div>
                </div>
              </td>
            </tr>`;
        });
        tableHtml += `
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>`;
        stockList.innerHTML = tableHtml;
      } else {
        // Render as cards with Bootstrap grid
        stockList.innerHTML = '<div class="row" id="stockGrid"></div>';
        
        // Render cards in the grid container
        for (const stock of stocks) {
          const symbol = typeof stock === 'object' ? stock.symbol : stock;
          // Get cached data to determine card border color
          const data = currentDataCache[symbol] || {};
          let cardClass = 'card shadow-sm stock-card';
          if (data.priceDir) {
            if (data.priceDir === 'up') {
              cardClass += ' border-success';
            } else if (data.priceDir === 'down') {
              cardClass += ' border-danger';
            }
          }
          
          // Render static card with placeholders and unique IDs
          let html = `<div class="col-md-6 col-lg-4 mb-3">
            <div class="${cardClass}" draggable="true" data-symbol="${symbol}">
              <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-2">
                  <h6 class="card-title mb-0">${symbol}</h6>
                  <span>
                    <i class="bi bi-bell alert-indicator${getAlerts(symbol).length > 0 ? ' active' : ''}" id="${symbol}-alertBell" title="${getAlerts(symbol).length > 0 ? 'View alerts' : 'Add alert'}" onclick="showAlertsModal('${symbol}')"></i>
                    <i class="notes-icon ${hasNotes(symbol) ? 'bi-sticky-fill has-notes' : 'bi-sticky'}" id="${symbol}-notesIcon" title="${hasNotes(symbol) ? 'Edit notes' : 'Add notes'}" onclick="showNotesModal('${symbol}')"></i>
                  </span>
                </div>
                <div class="row">
                  <div class="col-7">
                    <div class="price-display">
                      <div class="price mb-1" id="${symbol}-price">-</div>
                      <div class="d-flex align-items-center">
                        <small class="price-change me-1" id="${symbol}-pricePct"></small>
                        <span class="direction" id="${symbol}-priceDir"></span>
                      </div>
                    </div>
                  </div>
                  <div class="col-5">
                    <div class="sparkline text-end" id="${symbol}-spark"></div>
                  </div>
                </div>
                <div class="mt-2 pt-2 border-top">
                  <div class="row mb-2">
                    <div class="col-6">
                      <small class="text-muted d-block">High/Low</small>
                      <small class="fw-medium" id="${symbol}-highlow">-</small>
                    </div>
                    <div class="col-6 text-end">
                      <small class="text-muted d-block">Volume</small>
                      <small class="fw-medium" id="${symbol}-volume">-</small>
                    </div>
                  </div>
                  <div class="row mb-2">
                    <div class="col-6">
                      <small class="text-muted d-block">ATR(14)</small>
                      <small class="fw-medium">
                        <span id="${symbol}-atr14">-</span>
                        <span id="${symbol}-atr14Pct" class="neutral"></span>
                        <span id="${symbol}-atr14Ind" class="neutral"></span>
                      </small>
                    </div>
                    <div class="col-6 text-end">
                      <small class="text-muted d-block">Stop Loss</small>
                      <small class="fw-medium" id="${symbol}-stoploss">-</small>
                    </div>
                  </div>
                  <div class="row mb-2">
                    <div class="col-6">
                      <small class="text-muted d-block">RSI(14)</small>
                      <small class="fw-medium">
                        <span id="${symbol}-rsi">-</span>
                        <span id="${symbol}-rsiDir" class="neutral"></span>
                      </small>
                    </div>
                    <div class="col-6 text-end">
                      <small class="text-muted d-block">CCI(14)</small>
                      <small class="fw-medium">
                        <span id="${symbol}-cci">-</span>
                        <span id="${symbol}-cciDir" class="neutral"></span>
                      </small>
                    </div>
                  </div>
                  <div class="row mb-2">
                    <div class="col-6">
                      <small class="text-muted d-block">50MA</small>
                      <small class="fw-medium">
                        <span id="${symbol}-ma50">-</span>
                        <span id="${symbol}-ma50Dir" class="neutral"></span>
                      </small>
                    </div>
                    <div class="col-6 text-end">
                      <small class="text-muted d-block">150MA</small>
                      <small class="fw-medium">
                        <span id="${symbol}-ma150">-</span>
                        <span id="${symbol}-maDir" class="neutral"></span>
                      </small>
                    </div>
                  </div>
                  <div class="row mb-2">
                    <div class="col-6">
                      <small class="text-muted d-block">200MA</small>
                      <small class="fw-medium">
                        <span id="${symbol}-ma200">-</span>
                        <span id="${symbol}-ma200Dir" class="neutral"></span>
                      </small>
                    </div>
                    <div class="col-6 text-end">
                      <small class="text-muted d-block">Updated</small>
                      <small class="fw-medium" id="${symbol}-updated">-</small>
                    </div>
                  </div>
                  <div class="row mb-3">
                    <div class="col-12">
                      <small class="text-muted d-block">Smart Score</small>
                      <div id="${symbol}-smartScore" class="smart-score-container mt-1">
                        <div class="smart-score-value" id="${symbol}-smartScoreValue">-</div>
                        <div class="smart-score-sentiment" id="${symbol}-smartScoreSentiment">-</div>
                      </div>
                    </div>
                  </div>
                  <div class="d-flex justify-content-between align-items-center gap-2 mt-2">
                    <div class="d-flex gap-2">
                      <a href="https://finance.yahoo.com/quote/${symbol}" target="_blank" rel="noopener" class="btn btn-xs btn-outline-primary"><i class="bi bi-info-circle"></i></a>
                      <a href="https://www.tradingview.com/symbols/${symbol}/" target="_blank" rel="noopener" class="btn btn-xs btn-outline-success"><i class="bi bi-graph-up"></i></a>
                    </div>
                    <div class="dropdown">
                      <button class="btn btn-xs btn-outline-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        Actions
                      </button>
                      <ul class="dropdown-menu dropdown-menu-end">
                        ${generateStockDropdownMenu(symbol)}
                      </ul>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>`;
          
          const gridContainer = document.getElementById('stockGrid');
          if (gridContainer) {
            gridContainer.insertAdjacentHTML('beforeend', html);
          }
        }
        
        // Add drag-and-drop listeners for cards only
        setTimeout(() => {
          const cards = document.querySelectorAll('.stock-card');
          cards.forEach(card => {
            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragover', handleDragOver);
            card.addEventListener('dragleave', handleDragLeave);
            card.addEventListener('drop', handleDrop);
            card.addEventListener('dragend', handleDragEnd);
          });
        }, 0);
      }
      
      loading.style.display = 'none';
      
      // Always populate UI with existing cache data immediately
      await updateUIFromStorage();
      
      // Update table headers if in table view
      if (isTableView) {
        updateTableHeaders();
      }
    }

    // Update only the numbers for all stocks
    // This function is now only called by background update system
    // UI always reads from localStorage - this function only updates localStorage
    let fetchFailures = {};
    async function updateAllStockData(forceFetch = false) {
      const stocks = getTrackedStocks();
      let anyError = false;
      let updatedData = {};
      
      console.log(`updateAllStockData called with forceFetch=${forceFetch} for ${stocks.length} stocks`);
      
      for (const stock of stocks) {
        const symbol = typeof stock === 'object' ? stock.symbol : stock;
        let stockData = null;
        let shouldFetch = forceFetch;
        
        // Check if we have valid cached current data for this symbol
        if (currentDataCache[symbol] && currentDataCache[symbol].lastUpdated) {
          const age = Date.now() - currentDataCache[symbol].lastUpdated;
          if (age < CURRENT_DATA_CACHE_DURATION) {
            stockData = currentDataCache[symbol];
            console.log(`Using cached current data for ${symbol} (age: ${Math.round(age / 1000)}s)`);
          } else {
            shouldFetch = true;
            console.log(`Cache expired for ${symbol} (age: ${Math.round(age / 1000)}s), will fetch new data`);
          }
        } else {
          shouldFetch = true;
          console.log(`No cached data for ${symbol}, will fetch new data`);
        }
        
        // Only fetch new data if forced, cache expired, or no cache exists
        if (shouldFetch) {
          stockData = await fetchStockData(symbol);
          if (stockData) {
            // Store the fetched data in our cache
            updatedData[symbol] = stockData;
            console.log(`Successfully fetched and cached data for ${symbol}`);
          } else {
            fetchFailures[symbol] = (fetchFailures[symbol] || 0) + 1;
            anyError = true;
            console.error(`Failed to fetch data for ${symbol}`);
          }
        } else if (stockData) {
          // Use existing cached data
          updatedData[symbol] = stockData;
        }
      }
      
      // Update the current data cache with any new data we fetched
      if (Object.keys(updatedData).length > 0) {
        Object.assign(currentDataCache, updatedData);
        saveCurrentDataToStorage(currentDataCache);
        console.log(`Updated localStorage cache with ${Object.keys(updatedData).length} stocks`);
      }
      
      // Show error if any
      if (anyError) {
        const fetchError = document.getElementById('fetchError');
        if (fetchError) {
          fetchError.textContent = 'Some stocks failed to update. Check console for details.';
          fetchError.style.display = '';
        }
      } else {
        const fetchError = document.getElementById('fetchError');
        if (fetchError) {
          fetchError.style.display = 'none';
        }
      }
      
      // Update cache status
      updateCacheStatus();
      
      return updatedData;
    }

    // Render a simple sparkline SVG for an array of numbers
    function renderSparkline(arr) {
      if (!arr || arr.length < 2) return '';
      const w = 60, h = 18;
      const min = Math.min(...arr), max = Math.max(...arr);
      const norm = arr.map(v => (h-2) - ((v-min)/(max-min||1))*(h-4));
      let points = norm.map((y,i) => `${(i/(arr.length-1))*(w-2)+1},${y+1}`).join(' ');
      return `<svg width="${w}" height="${h}" style="vertical-align:middle;"><polyline fill="none" stroke="#888" stroke-width="2" points="${points}" /></svg>`;
    }

    // Force refresh historical data for all stocks and indexes (simplified for new system)
    async function forceRefreshHistoricalData() {
      const stocks = getTrackedStocks();
      // Extract symbols from stocks (handle both string and object formats)
      const stockSymbols = stocks.map(s => typeof s === 'object' ? s.symbol : s);
      const allSymbols = [...stockSymbols, ...MAJOR_INDEXES];
      
      if (allSymbols.length === 0) return;
      
      console.log(`Force refreshing all historical data for ${allSymbols.length} symbols...`);
      
      // Clear all historical cache to force fresh fetch
      allSymbols.forEach(symbol => {
        localStorage.removeItem(`historical_${symbol}`);
        localStorage.removeItem(`historical_${symbol}_timestamp`);
      });
      
      // Clear current data cache as well
      Object.keys(currentDataCache).forEach(symbol => {
        if (allSymbols.includes(symbol)) {
          delete currentDataCache[symbol];
        }
      });
      saveCurrentDataToStorage(currentDataCache);
      
      // Update cache status
      updateCacheStatus();
      
      // Perform background update to fetch fresh data
      await performBackgroundUpdate();
      // Force UI update after refresh
      await renderStocks();
      console.log('Force refresh completed and UI updated');
    }
    
    // Cache status and UI updates
    function updateCacheStatus() {
      const stocks = getTrackedStocks();
      const allSymbols = [...stocks, ...MAJOR_INDEXES];
      
      if (allSymbols.length === 0) {
        cacheStatus.style.display = 'none';
        return;
      }
      
      let oldestCache = Date.now();
      let newestCache = 0;
      let cachedCount = 0;
      let currentDataCount = 0;
      
      // Check historical data cache
      allSymbols.forEach(symbol => {
        const timestampKey = `historical_${symbol}_timestamp`;
        const timestamp = localStorage.getItem(timestampKey);
        if (timestamp) {
          cachedCount++;
          const ts = parseInt(timestamp);
          if (ts < oldestCache) oldestCache = ts;
          if (ts > newestCache) newestCache = ts;
        }
      });
      
      // Check current processed data cache
      allSymbols.forEach(symbol => {
        if (currentDataCache[symbol] && currentDataCache[symbol].lastUpdated) {
          currentDataCount++;
        }
      });
      
      if (cachedCount === 0) {
        cacheStatus.textContent = 'No historical data cached';
        cacheStatus.className = 'text-warning ms-3';
      } else {
        const ageHours = Math.round((Date.now() - oldestCache) / (60 * 60 * 1000));
        const stocksText = stocks.length > 0 ? `${stocks.length} stocks` : '';
        const indexesText = `${MAJOR_INDEXES.length} indexes`;
        const symbolsText = stocks.length > 0 ? `${stocksText} + ${indexesText}` : indexesText;
        
        if (ageHours < 1) {
          cacheStatus.textContent = `Data: Fresh (${cachedCount}/${allSymbols.length} cached, ${currentDataCount} processed) - ${symbolsText}`;
          cacheStatus.className = 'text-success ms-3';
        } else if (ageHours < 24) {
          cacheStatus.textContent = `Data: ${ageHours}h old (${cachedCount}/${allSymbols.length} cached, ${currentDataCount} processed) - ${symbolsText}`;
          cacheStatus.className = 'text-info ms-3';
        } else {
          cacheStatus.textContent = `Data: ${Math.round(ageHours/24)}d old (${cachedCount}/${allSymbols.length} cached, ${currentDataCount} processed) - ${symbolsText}`;
          cacheStatus.className = 'text-warning ms-3';
        }
      }
      cacheStatus.style.display = '';
    }
    
    // Refresh data for a single stock
    async function refreshSingleStock(symbol) {
      // Check if already refreshing this stock
      const refreshBtn = document.getElementById(`${symbol}-refreshBtn`);
      const refreshBtnCard = document.getElementById(`${symbol}-refreshBtnCard`);
      
      if ((refreshBtn && refreshBtn.disabled) || (refreshBtnCard && refreshBtnCard.disabled)) return;
      
      // Set loading state
      if (refreshBtn) {
        refreshBtn.disabled = true;
        refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';
        refreshBtn.title = 'Refreshing...';
      }
      if (refreshBtnCard) {
        refreshBtnCard.disabled = true;
        refreshBtnCard.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Refreshing...';
      }
      
      // Show loading in price field
      const priceEl = document.getElementById(`${symbol}-price`);
      const originalPrice = priceEl ? priceEl.textContent : '';
      if (priceEl) priceEl.textContent = 'Loading...';
      
      try {
        console.log(`Manual refresh requested for ${symbol}`);
        
        // Force fresh data fetch by clearing cache temporarily
        const originalHistoricalKey = `historical_${symbol}`;
        const originalTimestampKey = `historical_${symbol}_timestamp`;
        const cachedHistorical = localStorage.getItem(originalHistoricalKey);
        const cachedTimestamp = localStorage.getItem(originalTimestampKey);
        
        // Temporarily clear cache to force fresh fetch
        localStorage.removeItem(originalHistoricalKey);
        localStorage.removeItem(originalTimestampKey);
        
        // Fetch fresh data for this symbol
        const stockData = await fetchStockData(symbol);
        
        // Restore cache if fetch failed (to preserve data)
        if (!stockData && cachedHistorical && cachedTimestamp) {
          localStorage.setItem(originalHistoricalKey, cachedHistorical);
          localStorage.setItem(originalTimestampKey, cachedTimestamp);
        }
        
        if (stockData) {
          // Update cache with new data
          currentDataCache[symbol] = stockData;
          saveCurrentDataToStorage(currentDataCache);
          
          // Update UI immediately with new data
          updateSingleStockDisplay(symbol, stockData);
          
          console.log(`Successfully refreshed ${symbol}`);
          
          // Clear any error state
          const fetchError = document.getElementById('fetchError');
          if (fetchError) {
            fetchError.style.display = 'none';
          }
        } else {
          throw new Error('Failed to fetch fresh data');
        }
      } catch (error) {
        console.error(`Error refreshing ${symbol}:`, error);
        
        // Restore original price if available
        if (priceEl && originalPrice && originalPrice !== 'Loading...') {
          priceEl.textContent = originalPrice;
        } else if (priceEl) {
          priceEl.textContent = 'Error';
        }
        
        // Show error
        const fetchError = document.getElementById('fetchError');
        if (fetchError) {
          fetchError.textContent = `Failed to refresh ${symbol}. Please try again.`;
          fetchError.style.display = '';
        }
      } finally {
        // Reset button state
        if (refreshBtn) {
          refreshBtn.disabled = false;
          refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i>';
          refreshBtn.title = 'Refresh Data';
        }
        if (refreshBtnCard) {
          refreshBtnCard.disabled = false;
          refreshBtnCard.innerHTML = '<i class="bi bi-arrow-clockwise me-1"></i>Refresh';
        }
        
        // Update cache status
        updateCacheStatus();
      }
    }
    
    // Update cache status display
    function updateCacheStatus() {
      const stocks = getTrackedStocks();
      if (stocks.length === 0) {
        cacheStatus.style.display = 'none';
        return;
      }
      
      let oldestCache = Date.now();
      let newestCache = 0;
      let cachedCount = 0;
      
      stocks.forEach(stock => {
        const symbol = typeof stock === 'object' ? stock.symbol : stock;
        const timestampKey = `historical_${symbol}_timestamp`;
        const timestamp = localStorage.getItem(timestampKey);
        if (timestamp) {
          cachedCount++;
          const ts = parseInt(timestamp);
          if (ts < oldestCache) oldestCache = ts;
          if (ts > newestCache) newestCache = ts;
        }
      });
      
      if (cachedCount === 0) {
        cacheStatus.textContent = 'No historical data cached';
        cacheStatus.className = 'text-warning ms-3';
      } else {
        const ageHours = Math.round((Date.now() - oldestCache) / (60 * 60 * 1000));
        if (ageHours < 1) {
          cacheStatus.textContent = `Historical data: Fresh (${cachedCount}/${stocks.length})`;
          cacheStatus.className = 'text-success ms-3';
        } else if (ageHours < 24) {
          cacheStatus.textContent = `Historical data: ${ageHours}h old (${cachedCount}/${stocks.length})`;
          cacheStatus.className = 'text-info ms-3';
        } else {
          cacheStatus.textContent = `Historical data: ${Math.round(ageHours/24)}d old (${cachedCount}/${stocks.length})`;
          cacheStatus.className = 'text-warning ms-3';
        }
      }
      cacheStatus.style.display = '';
    }

    // Historical data refresh button (now in settings)

    const forceHistoricalBtn = document.getElementById('forceHistoricalBtn');
    let isRefreshing = false;

    forceHistoricalBtn.onclick = async function() {
      if (isRefreshing) return;
      isRefreshing = true;
      setRefreshBtnState(true, true);
      try {
        await forceRefreshHistoricalData();
      } finally {
        isRefreshing = false;
        setRefreshBtnState(false, true);
      }
    };
    
    // Manual refresh function that forces API fetch
    async function manualRefreshAllStocks() {
      await updateAllStockData(true);
    }

    function setRefreshBtnState(running, isHistoricalRefresh = false) {
      if (running) {
        forceHistoricalBtn.disabled = true;
        if (isHistoricalRefresh) {
          forceHistoricalBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Refreshing...';
        }
      } else {
        forceHistoricalBtn.disabled = false;
        forceHistoricalBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh All Historical Data';
      }
    }
    // Filter box
    filterInput.oninput = function() {
      renderStocks();
    };
    // Settings modal
// The auto refresh interval is now handled by the background update system (CURRENT_DATA_CACHE_DURATION)
// Keep the settings field for user control, and set default to 15 minutes (900 seconds)
let refreshInterval = Number(localStorage.getItem('refreshInterval')) || 900; // Default to 15 minutes (900 seconds)
    settingsBtn.onclick = function() {
      refreshIntervalInput.value = Math.round(refreshInterval / 60); // show in minutes
      darkModeSwitch.checked = document.body.classList.contains('dark-mode');
      tableViewSwitch.checked = isTableView;
      new bootstrap.Modal(settingsModal).show();
    };
saveSettingsBtn.onclick = function() {
      // Save email
      let emailInput = userEmailInput;
      if (!emailInput) {
        emailInput = document.getElementById('userEmail');
      }
      
      if (emailInput) {
        const email = emailInput.value.trim();
        try {
          localStorage.setItem('userEmail', email);
        } catch (error) {
          console.error('Error saving email to localStorage:', error);
          alert('Error saving email: ' + error.message);
        }
      }

      // Save refresh interval
      let val = Number(refreshIntervalInput.value);
      if (val >= 1 && val <= 60) { // 1-60 minutes
        refreshInterval = val * 60; // store as seconds
        localStorage.setItem('refreshInterval', refreshInterval);
        // Restart background update timer with new interval
        if (backgroundUpdateTimer) clearInterval(backgroundUpdateTimer);
        backgroundUpdateTimer = setInterval(async () => {
          console.log('Starting background update of stock data...');
          await performBackgroundUpdate();
        }, refreshInterval * 1000);
        console.log('Background update system restarted with interval:', refreshInterval, 'seconds');
      }
      
      // Save view preference
      const newTableView = tableViewSwitch.checked;
      if (newTableView !== isTableView) {
        isTableView = newTableView;
        localStorage.setItem('tableView', isTableView ? '1' : '0');
        renderStocks(); // Re-render with new view
      }
      
      // Save dark mode preference
      if (darkModeSwitch.checked) {
        document.body.classList.add('dark-mode');
        localStorage.setItem('darkMode', '1');
      } else {
        document.body.classList.remove('dark-mode');
        localStorage.setItem('darkMode', '0');
      }
      
      // Save Smart Alert settings
      if (smartAlertsSwitch) {
        smartAlertsEnabled = smartAlertsSwitch.checked;
        localStorage.setItem('smartAlertsEnabled', smartAlertsEnabled.toString());
      }
      
      if (smartAlertBuyThreshold && smartAlertBuyThreshold.value) {
        const buyThreshold = Number(smartAlertBuyThreshold.value);
        if (buyThreshold >= 50 && buyThreshold <= 100) {
          smartAlertBuyThresholdValue = buyThreshold;
          localStorage.setItem('smartAlertBuyThreshold', buyThreshold.toString());
        }
      }
      
      if (smartAlertSellThreshold && smartAlertSellThreshold.value) {
        const sellThreshold = Number(smartAlertSellThreshold.value);
        if (sellThreshold >= 0 && sellThreshold <= 50) {
          smartAlertSellThresholdValue = sellThreshold;
          localStorage.setItem('smartAlertSellThreshold', sellThreshold.toString());
        }
      }
      
      if (smartAlertEmailSwitch) {
        smartAlertEmailEnabled = smartAlertEmailSwitch.checked;
        localStorage.setItem('smartAlertEmailEnabled', smartAlertEmailEnabled.toString());
      }
      
      bootstrap.Modal.getInstance(settingsModal).hide();
    };
    // Dark mode CSS
    const darkStyle = document.createElement('style');
    darkStyle.textContent = `
      body.dark-mode { background: #181a1b !important; color: #eee; }
      body.dark-mode .container, body.dark-mode .container-fluid {
        background: linear-gradient(180deg, #23272b 0%, #23272b 80%, #181a1b 100%) !important;
        color: #eee;
      }
      body.dark-mode h1, body.dark-mode .container-fluid h1 {
        color: #f8f8fa;
        text-shadow: 0 2px 8px #000a;
      }
      body.dark-mode .stock-symbol { color: #f8d14b; }
      body.dark-mode .card { background: #23272b; color: #eee; }
      body.dark-mode .info-row .label { color: #bbb; }
      body.dark-mode .form-control { background: #23272b; color: #eee; border-color: #444; }
      body.dark-mode .form-control::placeholder {
        color: #bbb !important;
        opacity: 1 !important;
      }
      body.dark-mode .input-group { background: #23272b; }
      body.dark-mode .btn, body.dark-mode .btn-primary, body.dark-mode .btn-secondary, body.dark-mode .btn-outline-dark {
        background: #23272b; color: #eee; border-color: #444;
      }
      body.dark-mode .btn-close {
        filter: invert(1) grayscale(1);
      }
      body.dark-mode .modal-content { background: #23272b; color: #eee; border-color: #444; }
      body.dark-mode .modal-header, body.dark-mode .modal-footer { background: #23272b; border-color: #444; }
      body.dark-mode .form-label, body.dark-mode .form-check-label { color: #eee; }
      body.dark-mode .form-check-input:checked { background-color: #2ecc40; border-color: #2ecc40; }
      body.dark-mode .btn-outline-primary, body.dark-mode .btn-outline-success { color: #eee; border-color: #888; }
      body.dark-mode .btn-outline-primary:hover, body.dark-mode .btn-outline-success:hover { background: #444; }
      body.dark-mode .loading { color: #bbb; }
      body.dark-mode .stock-list { background: transparent; }
      body.dark-mode .text-danger { color: #ff4d4f !important; }
      body.dark-mode .up { color: #2ecc40; }
      body.dark-mode .down { color: #ff4d4f; }
      body.dark-mode .neutral { color: #bbb; }
      body.dark-mode .warning { color: #ffa500; }
      
      /* Dark mode Smart Score */
      body.dark-mode .smart-score-bullish { 
        background: linear-gradient(135deg, #1e4d2b 0%, #2d5a35 100%);
        color: #a3d5a8;
        border: 1px solid #2d5a35;
      }
      body.dark-mode .smart-score-bearish { 
        background: linear-gradient(135deg, #4d1e26 0%, #5a2d35 100%);
        color: #d5a3a8;
        border: 1px solid #5a2d35;
      }
      body.dark-mode .smart-score-neutral { 
        background: linear-gradient(135deg, #2a2d30 0%, #35383b 100%);
        color: #bbb;
        border: 1px solid #35383b;
      }
      body.dark-mode .table { 
        color: #eee; 
        --bs-table-bg: #23272b;
        --bs-table-border-color: #3a3d40;
      }
      body.dark-mode .table > :not(caption) > * > * { 
        border-bottom-color: #3a3d40;
        background-color: var(--bs-table-bg);
      }
      body.dark-mode .table-light { 
        background: #2a2d30 !important; 
        color: #eee;
        border-color: #3a3d40 !important;
      }
      body.dark-mode .table-light th {
        background: #2a2d30 !important;
        border-color: #3a3d40 !important;
        color: #f8f9fa !important;
        font-weight: 600;
      }
      body.dark-mode .table-hover tbody tr:hover { 
        background: #2a2d30 !important; 
        color: #fff;
      }
      body.dark-mode .table tbody tr:nth-of-type(odd) {
        background: rgba(255, 255, 255, 0.02);
      }
      body.dark-mode .sortable:hover { 
        background: #3a3d40 !important; 
        color: #fff !important;
        cursor: pointer;
      }
      body.dark-mode .table-responsive {
        border: 1px solid #3a3d40;
        border-radius: 8px;
      }
    `;
    document.head.appendChild(darkStyle);
    // Auto-enable dark mode if set
    if (localStorage.getItem('darkMode') === '1') {
      document.body.classList.add('dark-mode');
      darkModeSwitch.checked = true;
    }
    darkModeSwitch.onchange = function() {
      const enabled = darkModeSwitch.checked;
      document.body.classList.toggle('dark-mode', enabled);
      localStorage.setItem('darkMode', enabled ? '1' : '0');
      // Update table dark mode immediately
      const table = document.querySelector('.stock-table-sm');
      if (table) {
        table.classList.toggle('table-dark', enabled);
        table.classList.toggle('table-darkmode', enabled);
        const thead = table.querySelector('thead');
        if (thead) {
          thead.className = enabled ? 'table-dark' : 'table-light';
        }
      }
      // Optionally re-render stocks if needed
      renderStocks();
    };

    // Expose removeStock for inline onclick
    window.removeStock = removeStock;
    window.sortTable = sortTable;
    window.switchToIndexes = switchToIndexes;
    window.switchWatchlist = switchWatchlist;
    window.refreshSingleIndex = refreshSingleIndex;

    // Load settings from localStorage
    function loadSettings() {
      // Load email
      if (userEmailInput) {
        const savedEmail = localStorage.getItem('userEmail') || '';
        userEmailInput.value = savedEmail;
      } else {
        const emailInput = document.getElementById('userEmail');
        if (emailInput) {
          const savedEmail = localStorage.getItem('userEmail') || '';
          emailInput.value = savedEmail;
        }
      }
      
      // Load refresh interval
      if (refreshIntervalInput) {
        refreshIntervalInput.value = localStorage.getItem('refreshInterval') || '15';
      }
      
      // Load ATR thresholds
      const atrHighInput = document.getElementById('atrHighThresh');
      const atrLowInput = document.getElementById('atrLowThresh');
      if (atrHighInput) {
        atrHighInput.value = localStorage.getItem('atrHighThresh') || '1.5';
      }
      if (atrLowInput) {
        atrLowInput.value = localStorage.getItem('atrLowThresh') || '0.5';
      }
      
      // Load table view preference
      if (tableViewSwitch) {
        tableViewSwitch.checked = localStorage.getItem('tableView') === '1';
        isTableView = tableViewSwitch.checked;
      }
      
      // Load view mode preference (default to watchlist)
      currentViewMode = localStorage.getItem('currentViewMode') || 'watchlist';
      
      // Load dark mode preference
      if (darkModeSwitch) {
        darkModeSwitch.checked = localStorage.getItem('darkMode') === '1';
        if (darkModeSwitch.checked) {
          document.body.classList.add('dark-mode');
        }
      }
      
      // Load Smart Alert settings
      if (smartAlertsSwitch) {
        smartAlertsSwitch.checked = smartAlertsEnabled;
        smartAlertSettings.style.display = smartAlertsEnabled ? 'block' : 'none';
      }
      
      if (smartAlertBuyThreshold) {
        smartAlertBuyThreshold.value = smartAlertBuyThresholdValue;
      }
      
      if (smartAlertSellThreshold) {
        smartAlertSellThreshold.value = smartAlertSellThresholdValue;
      }
      
      if (smartAlertEmailSwitch) {
        smartAlertEmailSwitch.checked = smartAlertEmailEnabled;
      }
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize EmailJS if available
      if (window.emailjs && emailjs.init) {
        emailjs.init({ publicKey: 'B7kh1ObFueDe2hd5O' });
      }
      
      // Load settings from localStorage
      loadSettings();
      
      // Initialize Smart Alert toggle functionality
      setupSmartAlertToggle();
      
      // Request notification permission for Smart Alerts
      requestNotificationPermission();
      
      // Initialize watchlist tabs
      renderWatchlistTabs();
      
      // Load the appropriate view based on saved mode
      if (currentViewMode === 'indexes') {
        renderIndexes();
      } else if (currentViewMode === 'news') {
        renderNews();
      } else {
        // Default to watchlist - UI only, no API calls on initial load
        renderStocks(true); // Skip data update on initial load
      }
      
      // Check if indexes need initial data load
      const indexesNeedData = MAJOR_INDEXES.some(symbol => {
        const cachedData = currentDataCache[symbol];
        return !cachedData || !cachedData.lastUpdated;
      });
      
      // Update cache status on load
      updateCacheStatus();
      
      // If indexes need data and we're starting in indexes view, fetch minimal data
      if (indexesNeedData && currentViewMode === 'indexes') {
        console.log('Indexes view active and needs data - fetching initial index data...');
        // Trigger a quick fetch for indexes only if we're viewing them
        setTimeout(async () => {
          await performBackgroundUpdate();
        }, 100);
      }
      
      // Add dropdown positioning fix
      document.addEventListener('shown.bs.dropdown', function (event) {
        const dropdown = event.target.nextElementSibling;
        if (dropdown && dropdown.classList.contains('dropdown-menu')) {
          const rect = dropdown.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          const viewportWidth = window.innerWidth;
          
          // Check if dropdown goes below viewport
          if (rect.bottom > viewportHeight) {
            dropdown.classList.add('dropup');
            dropdown.style.top = 'auto';
            dropdown.style.bottom = '100%';
          }
          
          // Check if dropdown goes beyond right edge
          if (rect.right > viewportWidth) {
            dropdown.classList.add('dropdown-menu-end');
          }
        }
      });
      
      // Start background update system (15-minute intervals)
      startBackgroundUpdates();
      
      // Check if we need to perform initial data fetch
      const stocks = getTrackedStocks();
      const hasAnyCachedData = stocks.some(symbol => currentDataCache[symbol]);
      
      // Check if cached data is stale (older than 15 minutes)
      let hasStaleData = false;
      if (hasAnyCachedData) {
        const now = Date.now();
        hasStaleData = stocks.some(symbol => {
          const data = currentDataCache[symbol];
          return data && data.lastUpdated && (now - data.lastUpdated) > CURRENT_DATA_CACHE_DURATION;
        });
      }
      
      if (!hasAnyCachedData && stocks.length > 0) {
        console.log('No cached data found, performing initial background fetch...');
        setTimeout(() => performBackgroundUpdate(), 1000);
      } else if (hasStaleData) {
        console.log('Stale cached data detected, performing background refresh...');
        setTimeout(() => performBackgroundUpdate(), 2000);
      }
      
      // Initialize autocomplete system
      setupStockAutocomplete();
      
      // Pre-load symbol cache for faster fallback searches
      loadSymbolCache().catch(error => {
        console.warn('Symbol cache pre-loading failed:', error);
      });
      
      console.log('Stock tracking app initialized with background update system');
    });
  </script>
</body>
</html>